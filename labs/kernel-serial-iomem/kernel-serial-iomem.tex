\subchapter{Accessing I/O memory and ports}{Objective: read /
  write data from / to a hardware device}

Throughout the upcoming labs, we will implement a character driver
allowing to write data to additional CPU serial ports available on 
the BeagleBone, and to read data from them.

After this lab, you will be able to:

\begin{itemize}
\item Add an UART device to the board device tree
\item Practice with I/O ports and I/O memory to control the device and
  exchange data with it.
\end{itemize}

\section{Add UART devices}

Before developing a driver for additional UARTS on the board, we
need to add the corresponding descritions to the board Device Tree.

\section{Device initialization}

In the module initialization function, start by reserving the I/O
memory region starting at address (\code{0x44e09000}), for a size of
\code{SZ_512} (512 bytes). The \code{UART} constants are already
defined in Linux kernel headers (\code{serial_reg.h}).

Compile your module, load it and make sure that this memory region
appears in \code{/proc/iomem}.

Now, obtain a virtual address corresponding to the start of this
memory area.

Don't forget to undo all the above in the module exit function!

\section{Standalone write routine}

Implement a C routine taking one character as a parameter and writing
it to the serial port, using the following steps:

\begin{enumerate}
\item Wait until the \code{UART_LSR_THRE} bit gets set in the
  \code{UART_LSR} register (\code{UART_LSR} is an index number for
  this register. You'll have to multiply it by 4 to get an offset in
  the I/O memory region previously remapped). You can busy-wait for
  this condition to happen. In the busy-wait loop, you can call the
  \code{cpu_relax()} kernel function to ensure the compiler won't
  optimise away this loop.

\item Write the character to the \code{UART_TX} register.

\end{enumerate}

Note that all the I/O registers of the AM335x SoC are 32 bits wide.

Add a call to this routine from your module init function. Recompile
your module and load it on the target. You should see the
corresponding character in picocom, still showing what was written to
the serial line by the board.

\section{Driver sanity check}

Remove your module and try to load it again. If the second attempt to
load the module fails, it is probably because your driver doesn't
properly free the resources it allocated or register, either at module
exit time, or after a failing during the module init function. Check
and fix your module init and exit functions if you have such a
problem.
