\subchapter{Output-only misc driver}{Objective: implement the
  write part of a {\em misc} driver}

After this lab, you will be able to:

\begin{itemize}
\item Write a simple misc driver, allowing to write data to the
  serial ports of your Beaglebone.
\item Write simple \code{file_operations} functions for a device,
  including \code{ioctl} controls.
\item Copy data from user memory space to kernel memory space and
  eventually to the device.
\item You will practice kernel standard error codes a little bit too.
\end{itemize}

You must have completed the previous lab to work on this one. 

\section{Misc driver registration}

In the same way we added an input interface to our Nunchuk driver, it is
now time to give an interface to our serial driver. As our needs are
simple, we won't use the {\em Serial framework} provided by the Linux
kernel, but will use the {\em Misc framework} to implement a simple
character driver.

Let's start by adding the infrastructure to register a {\em misc}
driver.

The first thing to do is to create:

\begin{itemize}
\item An \code{feserial_write()} write file operation stub.
      See the slides or the code for the prototype to use.
      Just place a \code{return -EINVAL;} statement in the function
      body so far, to signal that there something wrong with this
      function so far.
\item Similarly, an \code{feserial_read()} read file operation stub.
\item A \code{file_operations} structure declaring these file
      operations.
\end{itemize}

The next step is to create a \code{miscdevice} structure and initialize
it. However, we are facing the same usual constraint to handle multiple
devices. Like in the Nunchuk driver, we have to add such a structure
to our device specific private data structure:

\begin{verbatim}
struct feserial_dev {
        struct miscdevice miscdev;
        void __iomem *regs;
};
\end{verbatim}

Now, at the end of the \code{probe()} routine, when the device is fully ready
to work, you can now initialize the \code{miscdevice} structure
for each found device:

\begin{itemize}
\item To get an automatically assigned minor number 
\item To specify a name for the device file in {\em devtmpfs}. We
      propose to use
      \code{kasprintf(GFP_KERNEL, "feserial-\%x", res->start)}.
      \code{kasprintf()} allocates a buffer and runs \code{ksprintf()}
      to fill its contents.
      Don't forget to call \code{kfree()} on this buffer in
      the \code{remove()} function!
\item To pass the file operations structure that you defined.
\end{itemize}

See the lectures for details if needed!

The last things to do (at least to have a {\em misc} driver, even if 
its file operations are not ready yet), are to add the registration and
deregistration routines.

Make sure that your driver compiles and loads well, and that you
now see two new device files in \code{\dev}.

At this stage, make sure you can load and unload the driver multiple
times. This should reveal registration and deregistration issues if
there are any.

\section{Apply a kernel patch}


Now, add code to your write function, to copy user data to the serial
port, writing characters one by one.

Once done, compile and load your module. Test that your \code{write} function
works properly by using:

\begin{verbatim}
echo "test" > /dev/serial
\end{verbatim}

The \code{test} string should appear on the remote side (i.e in
the \code{picocom} process connected to \code{/dev/ttyUSB0}).

You'll quickly discover than newlines do not work properly. To fix
this, when the userspace application sends \verb+"\n"+, you must send
\verb+"\n\r"+ to the serial port.

\section{Driver sanity check}

Once again, make sure that you can load your module again after
removing it.

\section{Ioctl operation}

We would like to maintain a counter of the number of characters
written through the serial port. So we need to implement two
\code{unlocked_ioctl()} operations:
\begin{itemize}

 \item \code{SERIAL_RESET_COUNTER}, which as its name says, will
   reset the counter to zero

 \item \code{SERIAL_GET_COUNTER}, which will return in a variable
   passed by address the current value of the counter.

\end{itemize}

Two already-compiled test applications are already available in the
\code{nfsroot/root/} directory, with their source code. They assume that
\code{SERIAL_RESET_COUNTER} is ioctl operation \code{0} and that
\code{SERIAL_GET_COUNTER} is ioctl operation \code{1}.
