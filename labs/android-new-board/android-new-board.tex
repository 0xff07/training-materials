\subchapter{Supporting a new board}{Learn how to make Android on new
hardware}

After this lab, you will be able to:
\begin{itemize}
  \item Boot Android on a real hardware
  \item Troubleshoot simple problems on Android
  \item Generate a working build
\end{itemize}

\section{Download the source code}

Go to the directory holding the Android source code (either
\code{/opt/android} or \code{$HOME/felabs/android/source}).

We will use the TI-flavored Android build, named rowboat, for our
board. This should make most of the port ready to use, and only a few
fixes here and there will be needed.

\code{repo} allows to download a new Android tree in a smart way,
downloading only the differences between the new manifest we would
give him and the current code we have. To do so, we first need to
change the manifest we use to the rowboat's one.

\begin{verbatim}
repo init -u git://git.free-electrons.com/android/rowboat/manifest.git \
        -b free-electrons -m rowboat-jb-am335x.xml
\end{verbatim}

Now, let's run the big download job:
\begin{verbatim}
repo sync -c -j4
\end{verbatim}

We then need to reapply our \code{ccache} commit.
\begin{verbatim}
cd prebuilts/misc
git cherry-pick 81012983
cd ../..
\end{verbatim}

\section{Build Android for the BeagleBone Black}

As we said earlier, rowboat already includes support for the
BeagleBone Black we're using. To compile it, we have to use lunch, in
the same way we did previously:

\begin{verbatim}
source build/envsetup.sh
lunch beagleboneblack-eng
\end{verbatim}

Make sure we are using \code{ccache}:

\begin{verbatim}
export USE_CCACHE=1
export CCACHE_DIR=$HOME/felabs/android/ccache-rowboat
\end{verbatim}
or, depending on your setup,
\begin{verbatim}
export CCACHE_DIR=/opt/ccache-rowboat
\end{verbatim}

Then, we will need an extra package that will be required by the build system
to build the kernel images:

\begin{verbatim}
sudo apt-get install uboot-mkimage
\end{verbatim}

And finally, we can start the compilation:

\begin{verbatim}
make OMAPES=4.x -jX
\end{verbatim}

Once again, you can expect this build job to take quite a long time (a
few hours) to run, even on a recent and rather fast laptop.

This job will build four images in
\code{out/target/product/beagleboneblack}: \code{cache.img},
\code{ramdisk.img}, \code{system.img} and \code{userdata.img}.

These images are the one usually generated by the Android build
system. However, rowboat provides all the tools needed to flash an
image to an SD card, but they do use a tarball containing the whole
Android system.

To create such a tarball, you can use the following make target:

\begin{verbatim}
make OMAPES=4.x fs_tarball
\end{verbatim}

It will generate in \code{out/target/product/beagleboneblack} a
\code{rootfs.tar.bz2} tarball holding all the files needed for Android
to boot.

We will now be able to boot on this image, using NFS to ease the
development process.

\section{Setting up serial communication with the board}

To see the board boot, we need to read the first boot messages issued
on the board's serial port.

Your instructor will provide you with a special serial cable for the
Beaglebone, that is basically a USB-to-serial adapter for the
connection with your laptop.

When you plug in this adaptor, a serial port should appear on your
workstation: \code{/dev/ttyUSB0}.

You can also see this device appear by looking at the output of the
\code{dmesg} command.

To communicate with the board through the serial port, install a
serial communication program, such as \code{picocom}:
\footnote{\code{picocom} is one of the simplest utilities to access a
  serial console. \code{minicom} looks more featureful, but is also
  more complex to configure.}

\begin{verbatim}
sudo apt-get install picocom
\end{verbatim}

You also need to make your user belong to the \code{dialout} group to be
allowed to write to the serial console:

\begin{verbatim}
sudo adduser $USER dialout
\end{verbatim}

You need to log out and in again for the group change to be effective.

Run \code{picocom -b 115200 /dev/ttyUSB0}, to start serial
communication on \code{/dev/ttyUSB0}, with a baudrate of 115200. If
you wish to exit \code{picocom}, press \code{[Ctrl][a]} followed by
\code{[Ctrl][x]}.

\section{Load the kernel from TFTP}

Later on, we will transfer files from the development workstation to
the board using the TFTP protocol, which works on top of an Ethernet
connection.

To start with, install and configure a TFTP server on your development
workstation.

\begin{verbatim}
apt-get install tftpd-hpa
\end{verbatim}

With a network cable, connect the Ethernet port of your board to the
one of your computer. If your computer already has a wired connection
to the network, your instructor will provide you with a USB Ethernet
adapter. A new network interface, probably \code{eth1} or \code{eth2},
should appear on your Linux system.

To configure this network interface on the workstation side, click on
the {\em Network Manager} tasklet on your desktop, and select {\em
  Edit Connections}.

\begin{center}
\includegraphics[width=8cm]{labs/android-new-board/network-config-1.png}
\end{center}

Select the new {\em wired network connection}:

\begin{center}
\includegraphics[width=8cm]{labs/android-new-board/network-config-2.png}
\end{center}

In the \code{IPv4 Settings} tab, press the \code{Add} button
and make the interface use a static IP
address, like \code{192.168.0.1} (of course, make sure that this
address belongs to a separate network segment from the one of the main
company network).

\begin{center}
\includegraphics[width=8cm]{labs/android-new-board/network-config-3.png}
\end{center}

You can use \code{255.255.255.0} as \code{Netmask}, and leave the
\code{Gateway} field untouched (if you click on the \code{Gateway} box, you
will have to type a valid IP address, otherwise you won't be apply to
click on the \code{Apply} button).

Now, configure the network on the board in U-Boot by setting the \code{ipaddr}
and \code{serverip} environment variables:

\begin{verbatim}
setenv ipaddr 192.168.0.100
setenv serverip 192.168.0.1
\end{verbatim}

In case the board was previously configured in a different way, we
also turn off automatic booting after commands that can be used to
copy a kernel to RAM:

\begin{verbatim}
setenv autostart no
\end{verbatim}

To make these settings permanent, save the environment:

\begin{verbatim}
saveenv
\end{verbatim}

Now switch your board off and on again\footnote{Power cycling your
  board is needed to make your \code{ethaddr} permanent, for obscure
  reasons. If you don't, U-boot will complain that \code{ethaddr} is not
  set.}.

You can then test the TFTP connection. \code{tftpd} stores the files
it serves in the \code{/var/lib/tftpboot} directory on your
workstation. So first, put a small text file in this directory and
then, from U-Boot, do:

\begin{verbatim}
tftp 0x80000000 textfile.txt
\end{verbatim}

{\bf Caution: known issue in Ubuntu 12.04 and later}:
if this command doesn't work, you may have to stop the server
and start it again every time you boot your workstation:

\begin{verbatim}
sudo service tftpd-hpa restart
\end{verbatim}

The \code{tftp} command should have downloaded
the \code{textfile.txt} file from your development
workstation into the board's memory at location 0x80000000 (this
location is part of the board DRAM). You can verify that the download
was successful by dumping the contents of the memory:

\begin{verbatim}
md 0x80000000
\end{verbatim}

Now, we can start loading our kernel.

\begin{itemize}
\item On your workstation, copy the file
  \code{kernel/arch/arm/boot/uImage} to the directory exposed by the
  TFP server.
\item On the target, load \code{uImage} from TFTP into RAM at address
  \code{0x80000000}
  \begin{itemize}
  \item \code{tftp 0x80000000 uImage}
  \end{itemize}
\item Boot the kernel
  \begin{itemize}
  \item \code{bootm 0x80000000}
  \end{itemize}
\end{itemize}

You should see Linux boot and finally hang with the following message:

\begin{verbatim}
Waiting for root device /dev/mmcblk0p2...
\end{verbatim}

This is expected: we haven't provided a working root filesystem for
our device yet.

You can now automate all this every time the board is booted or
reset. Reset the board, and specify a different \code{bootcmd}:

\begin{verbatim}
setenv bootcmd 'tftp 80000000 uImage; bootm 80000000'
saveenv
\end{verbatim}

\section{Creating the SDcard}

Because Android has permissions issues when using an NFS volume as
\code{/data}, we have to use an Android SDcard that we'll let in the
slot. Android will mount it and use it for \code{/data}.

Your instructor will provide such an SDcard. It has been prepared
with:

\begin{verbatim}
sudo ./external/ti_android_utilities/am335x/mk-mmc/mkmmc-android.sh \
  /dev/sdX u-boot/MLO u-boot/u-boot.img kernel/arch/arm/boot/uImage \
  ./external/ti_android_utilities/am335x/u-boot-env/uEnv_beagleboneblack.txt \
  ./out/target/product/beagleboneblack/rootfs.tar.bz2
\end{verbatim}

\section{Setting up the NFS server}

Create a \code{nfsroot} directory in the \code{felabs/android}
directory. This \code{nfsroot} directory will be used to store the
contents of our new root filesystem.

Install the NFS server by installing the \code{nfs-kernel-server}
package if you don't have it yet. Once installed, edit the
\code{/etc/exports} file as root to add the following line, assuming that the
IP address of your board will be \code{192.168.0.100}:

\footnotesize
\begin{verbatim}
/home/<user>/felabs/android/nfsroot 192.168.0.100(rw,no_root_squash,no_subtree_check)
\end{verbatim}
\normalsize

Make sure that the path and the options are on the same line.
Also make sure that there is no space between the IP address and the NFS
options, otherwise default options will be used for this IP address,
causing your root filesystem to be read-only.

Then, restart the NFS server:

\begin{verbatim}
sudo /etc/init.d/nfs-kernel-server restart
\end{verbatim}

\section{Booting the system}

First, boot the board to the U-Boot prompt. Before booting the kernel,
we need to tell it that the root filesystem should be mounted over
NFS, by setting some kernel parameters.

Use the following U-Boot command to do so, {\bf in just 1 line}
(Caution: in \code{ttyO0} below, it's the capital letter \code{O}, like in
{\bf O}MAP and then the number zero):

\begin{verbatim}
setenv bootargs console=ttyO0,115200 root=/dev/nfs ip=192.168.0.100
   nfsroot=192.168.0.1:/home/<user>/felabs/android/nfsroot rw
   androidboot.console=ttyO0 init=/init
\end{verbatim}

Of course, you need to adapt the IP addresses to your exact network
setup. Save the environment variables (with \code{saveenv}).

If you later want to make changes to this setting, you can type the
below command in U-boot:

\begin{verbatim}
editenv bootargs
\end{verbatim}

Now, boot your system. The kernel should be able to mount the root
filesystem over NFS:

\begin{verbatim}
[    7.467895] VFS: Mounted root (nfs filesystem) readonly on device 0:12.
\end{verbatim}

If the kernel fails to mount the NFS filesystem, look carefully at the
error messages in the console. If this doesn't give any clue, you can
also have a look at the NFS server logs in \code{/var/log/syslog}.

However, at this stage, the kernel should complain, saying that it
can't find an init application:

\footnotesize
\begin{verbatim}
Kernel panic - not syncing: No init found.  Try passing init= option to kernel.
  See Linux Documentation/init.txt for guidance.
\end{verbatim}
\normalsize

Obviously, our root filesystem being empty, there isn't such an
application yet.

\section{Booting the board}

Go into the \code{nfsroot} directory, and extract the rootfs tarball
we created previously using
\code{sudo tar xvf ../source/out/target/product/beagleboneblack/rootfs.tar.bz2}.

Once there's extraction's done, you can reboot the board. On the
serial port, you should see Android going through its boot process,
until you finally have a shell on the serial link and the screen
working properly.

\section{Fix the blank screen}

After the android logo, the screen will turn black. This is actually
the backlight turning almost off.

You can find the controls for the backlight in
\code{/sys/class/backlight} and as this is controlled by a PWM some
other controls are available in \code{/sys/class/pwm}. Play with those
controls until you find the values that are working.

To make those changes permanently, you will have to edit the kernel
code. The used PWM is defined is the \code{am335xevm} board file, in
the \code{arch/arm/mach-omap2} folder.

Once you're done, rebuild the kernel, boot it, and you should be able
to read the screen now!

