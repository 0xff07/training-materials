\subchapter{Sleeping and handling interrupts}{Objective: learn how to
  register and implement a simple interrupt handler, and how to put a
  process to sleep and wake it up at a later point}

During this lab, you will:

\begin{itemize}
\item Register an interrupt handler for the serial controller of the
  Beaglebone
\item See how Linux handles shared interrupt lines
\item Implement the read() operation of the serial port driver to put
  the process to sleep when no data are available
\item Implement the interrupt handler to wake-up the sleeping process
  waiting for received characters
\item Handle communication between the interrupt handler and the
  read() operation.
\end{itemize}

\section{Setup}

This lab is a continuation of the {\em Output-only character driver
  lab}, so we'll re-use the code in
\code{$HOME/felabs/linux/character}. Your Beaglebone should boot over
NFS and mount \code{/home/<user>/felabs/linux/character/nfsroot/} as
the root filesystem.

\section{Register the handler}

First, declare an interrupt handler function. Then, in the module
initialization function, we need to register this handler to an IRQ
number.

Nowadays, Linux is using a virtual IRQ number that it derives from the
hardware interrupt number. This virtual number is created through the
\code{irqdomain} mechanism. The hardware IRQ number to use is
\code{72} for the UART. You can get a virtual IRQ number by using the
\code{irq_create_mapping} function.

Then, pass the newly created virtual interrupt to \code{request_irq}
along with the interrupt handler to register your interrupt in the
kernel. Note that this IRQ is shared, so the appropriate flags must be
passed at registration time.

Then, in the interrupt handler, just print a message and return
\code{IRQ_HANDLED} (to tell the kernel that we have handled the
interrupt).

You'll also need to enable the interrupt when receiving a new
character. To do so, in the initialization of the module, write the
\code{UART_IER_RDI} bit in the \code{UART_IER} register.

Compile and load your module. Send a character on the serial link, and
look at the kernel logs: they are full of our message indicating that
interrupts are occurring, even if we only sent one character! It shows
you that interrupt handlers should do a little bit more when an
interrupt occurs.

\section{Enable and filter the interrupts}

In fact, the hardware will replay the interrupt until you acknowledge
it. Linux will only dispatch the interrupt event to the rightful
handler, hoping that this handler will acknowledge it. What we
experienced here is called an \code{interrupt flood}.

Now, in our interrupt handler, we want to acknowledge the
interrupt. On the UART controller we drive, it's done simply by
reading the content of the \code{UART_RX} register, which holds the
next character received. You can display the value you read to see
that the driver will receive whatever character you sent.

Compile and load your driver. Have a look at the kernel messages. You
should no longer be flooded with interrupt messages. In the kernel
log, you should see the message of our interrupt handler. If not,
check your code once again and ask your instructor for clarification!

\section{Sleeping, waking up and communication}

Now, we would like to implement the \code{read()} operation of our
driver so that a userspace application reading from our device can
receive the characters from the serial port.

First, we need a communication mechanism between the interrupt handler
and the \code{read()} operation. We will implement a very simple
circular buffer. So let's declare a global buffer in our driver:

\begin{verbatim}
#define SERIAL_BUFSIZE 16
static char serial_buf[SERIAL_BUFSIZE];
\end{verbatim}

Two integers that will contain the next location in the circular
buffer that we can write to, and the next location we can read from:

\begin{verbatim}
static int serial_buf_rd, serial_buf_wr;
\end{verbatim}

In the interrupt handler, store the received character at location
\code{serial_buf_wr} in the circular buffer, and increment the value
of \code{serial_buf_wr}. If this value reaches \code{SERIAL_BUFSIZE},
reset it to zero.

In the \code{read()} operation, if the \code{serial_buf_rd} value is
different from the \code{serial_buf_wr} value, it means that one
character can be read from the circular buffer. So, read this
character, store it in the userspace buffer, update the
\code{serial_buf_rd} variable, and return to userspace (we will only
read one character at a time, even if the userspace application
requested more than one).

Now, what happens in our \code{read()} function if no character is
available for reading (i.e, if \code{serial_buf_wr} is equal to
\code{serial_buf_rd})? We should put the process to sleep!

To do so, declare a global wait queue in our driver, named for example
\code{serial_wait}. In the \code{read()} function, use
\code{wait_event_interruptible()} to wait until \code{serial_buf_wr}
is different from \code{serial_buf_rd}. And in the interrupt handler,
after storing the received characters in the circular buffer, use
\code{wake_up()} to wake up all processes waiting on the wait queue.

Compile and load your driver. Run \code{cat /dev/serial} on the
target, and then in Picocom on the development workstation side, type
some characters. They should appear on the remote side if everything
works correctly!

Don't be surprised if the keys you type in Picocom don't appear on the
screen. This happens because they are not echoed back by the target.
