\subchapter
{Application development with Buildroot}
{Objectives:
  \begin{itemize}
  \item Build and run your own application
  \item Remote debug your application
  \item Use \code{<pkg>_OVERRIDE_SRCDIR}
  \item Set up Eclipse for Buildroot application development
  \end{itemize}
}

\section{Build and run your own application}

Let's create your own little application that we will use for
demonstration in this lab. Create a folder \code{$HOME/felabs/myapp},
and inside this folder a single C file called \code{myapp.c} with the
following contents:

\begin{verbatim}
#include <stdio.h>

int main(void) {
	printf("Hello World\n");
	return 0;
}
\end{verbatim}

To build this application, we'll use the cross-compiler generated by
Buildroot. To make this easy, let's add the Buildroot host directory
into our PATH:

\begin{verbatim}
export PATH=$HOME/felabs/buildroot/output/host/usr/bin:$PATH
\end{verbatim}

Now you can build your application easily:

\begin{verbatim}
arm-linux-gnueabihf-gcc -o myapp myapp.c
\end{verbatim}

Copy the myapp binary to your target using scp:

\begin{verbatim}
scp myapp root@192.168.0.2:
\end{verbatim}

And run the \code{myapp} application on your target.

Now, let's extend the application a little bit more to use a library,
the \code{libconfig} library we've already used in a previous
lab. Change the source code of the application to the one provided in
this lab data directory, \code{myapp.c}.

If you try to build this application with just:

\begin{verbatim}
arm-linux-gnueabihf-gcc -o myapp myapp.c
\end{verbatim}

It fails to build because it does not link with \code{libconfig}. So
you can manually do:

\begin{verbatim}
arm-linux-gnueabihf-gcc -o myapp myapp.c -lconfig
\end{verbatim}

Since \code{libconfig.so} is in \code{output/staging/usr/lib} and the
compiler is configured to automatically look in \code{output/staging}
as its {\em sysroot}, it works fine.

However, there's a better solution: using {\em pkg-config}. Buildroot
has installed a special version of \code{pkg-config} in
\code{output/host/usr/bin}, which you can query for libraries
available for the target. Run:

\begin{verbatim}
pkg-config --list-all
\end{verbatim}

And check you have \code{libconfig} mentionned. You can query the
compiler and linker flags for \code{libconfig}:

\begin{verbatim}
pkg-config --cflags --libs libconfig
\end{verbatim}

And use that to build your application:

\begin{verbatim}
arm-linux-gnueabihf-gcc -o myapp myapp.c $(pkg-config --cflags --libs libconfig)
\end{verbatim}

In the case of \code{libconfig}, it doesn't simplify a lot because the
compiler and linker flags are simple, but for some other libraries,
they are more complicated.

Copy the new version of \code{myapp} to your target, and run
it. Create a \code{myapp.cfg} config file, and run your application
again.

\section{Remote debug your application}

Our application is simple and works, but what if you need to debug it?
So let's set up remote debugging.

In Buildroot \code{menuconfig}, enable
\code{Copy gdb server to the Target} in the \code{Toolchain}
menu. Since we don't want to rebuild everything, we will force only
the reinstallation of the \code{toolchain-external} package. So just
do: \code{make toolchain-external-reinstall all}. Note that due to a
minor bug in Buildroot 2015.02, you need to apply the patch
\code{0001-toolchain-external-fix-rebuild-reinstall-for-Linaro-.patch}
provided in this lab's data directory, for this
\code{toolchain-external-reinstall} command to work.

You can reflash your system, or alternatively, just copy
\code{output/target/usr/bin/gdbserver} to the target \code{/usr/bin/}
directory using \code{scp}.

To do some appropriate debugging, we need to have debugging symbols
available. So we need to do two things:

\begin{enumerate}

\item Rebuild our application with the \code{-g} flag.

\item Rebuild the Buildroot system with debugging symbols, so that
  shared libraries have debugging symbols. However, since we don't
  want to rebuild the entire Buildroot system now, we'll use a trick
  and rebuild only the library we need to have the debugging symbols
  for: \code{libconfig}. To achieve this, first go to Buildroot
  \code{menuconfig}, and in \code{Build options}, enable
  \code{build packages with debugging symbols}. Then, do \code{make
    libconfig-dirclean all} to force the rebuild of just
  \code{libconfig}.

\end{enumerate}

Now, on your target, start {\em gdbserver} in multi-process mode,
listening on TCP port 2345:

\begin{verbatim}
gdbserver --multi localhost:2345
\end{verbatim}

Back on the host, run the cross-gdb with the \code{myapp} application
as argument:

\begin{verbatim}
arm-linux-gnueabihf-gdb myapp
\end{verbatim}

We need to tell \code{gdb} where the libraries can be found:

\begin{verbatim}
(gdb) set solib-search-path output/staging/lib:output/staging/lib/arm-linux-gnueabihf/:output/staging/usr/lib:output/staging/usr/lib/arm-linux-gnueabihf/
\end{verbatim}

And then connect to the target:

\begin{verbatim}
(gdb) target extended-remote 192.168.0.2:2345
\end{verbatim}

Let's put a breakpoint on the \code{main} function, and start the
program:

\begin{verbatim}
(gdb) break main
(gdb) run
\end{verbatim}

It stops on the first line of the \code{main} function, which is the
call to \code{config_init}, implemented by the \code{libconfig}
library. If you do the {\em gdb} instruction \code{step}, {\em gdb}
will step into the function, so you can follow what happens. After
having done \code{step} once, you can do \code{backtrace} to see that
you are in the function \code{config_init} called by \code{main}:

\begin{verbatim}
(gdb) backtrace
#0  config_init (config=0xbefffc3c) at libconfig.c:725
#1  0x000106f0 in main () at myapp.c:11
\end{verbatim}

\section{Use {\tt <pkg>\_OVERRIDE\_SRCDIR}}

\section{Use the Eclipse IDE with Buildroot}
