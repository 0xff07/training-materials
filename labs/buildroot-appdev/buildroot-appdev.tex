\subchapter
{Application development with Buildroot}
{Objectives:
  \begin{itemize}
  \item Build and run your own application
  \item Remote debug your application
  \item Use \code{<pkg>_OVERRIDE_SRCDIR}
  \item Set up Eclipse for Buildroot application development
  \end{itemize}
}

\section{Build and run your own application}

Let's create your own little application that we will use for
demonstration in this lab. Create a folder \code{$HOME/felabs/myapp},
and inside this folder a single C file called \code{myapp.c} with the
following contents:

\begin{verbatim}
#include <stdio.h>

int main(void) {
	printf("Hello World\n");
	return 0;
}
\end{verbatim}

To build this application, we'll use the cross-compiler generated by
Buildroot. To make this easy, let's add the Buildroot host directory
into our PATH:

\begin{verbatim}
export PATH=$HOME/felabs/buildroot/output/host/usr/bin:$PATH
\end{verbatim}

Now you can build your application easily:

\begin{verbatim}
arm-linux-gnueabihf-gcc -o myapp myapp.c
\end{verbatim}

Copy the myapp binary to your target using scp:

\begin{verbatim}
scp myapp root@192.168.0.2:
\end{verbatim}

And run the \code{myapp} application on your target.

Now, let's extend the application a little bit more to use a library,
the \code{libconfig} library we've already used in a previous
lab. Change the source code of the application to the one provided in
this lab data directory, \code{myapp.c}.

If you try to build this application with just:

\begin{verbatim}
arm-linux-gnueabihf-gcc -o myapp myapp.c
\end{verbatim}

It fails to build because it does not link with \code{libconfig}. So
you can manually do:

\begin{verbatim}
arm-linux-gnueabihf-gcc -o myapp myapp.c -lconfig
\end{verbatim}

Since \code{libconfig.so} is in \code{output/staging/usr/lib} and the
compiler is configured to automatically look in \code{output/staging}
as its {\em sysroot}, it works fine.

However, there's a better solution: using {\em pkg-config}. Buildroot
has installed a special version of \code{pkg-config} in
\code{output/host/usr/bin}, which you can query for libraries
available for the target. Run:

\begin{verbatim}
pkg-config --list-all
\end{verbatim}

And check you have \code{libconfig} mentionned. You can query the
compiler and linker flags for \code{libconfig}:

\begin{verbatim}
pkg-config --cflags --libs libconfig
\end{verbatim}

And use that to build your application:

\begin{verbatim}
arm-linux-gnueabihf-gcc -o myapp myapp.c $(pkg-config --cflags --libs libconfig)
\end{verbatim}

In the case of \code{libconfig}, it doesn't simplify a lot because the
compiler and linker flags are simple, but for some other libraries,
they are more complicated.

Copy the new version of \code{myapp} to your target, and run
it. Create a \code{myapp.cfg} config file, and run your application
again.

\section{Remote debug your application}

Our application is simple and works, but what if you need to debug it?
So let's set up remote debugging.

In Buildroot \code{menuconfig}, enable
\code{Copy gdb server to the Target} in the \code{Toolchain}
menu. Since we don't want to rebuild everything, we will force only
the reinstallation of the \code{toolchain-external} package. So just
do:

\begin{verbatim}
make toolchain-external-reinstall all
\end{verbatim}

Note that due to a minor bug in Buildroot 2015.02, you need to apply
the patch
\code{0001-toolchain-external-fix-rebuild-reinstall-for-Linaro-.patch}
provided in this lab's data directory, for this
\code{toolchain-external-reinstall} command to work.

You can reflash your system, or alternatively, just copy
\code{output/target/usr/bin/gdbserver} to the target \code{/usr/bin/}
directory using \code{scp}.

To do some appropriate debugging, we need to have debugging symbols
available. So we need to do two things:

\begin{enumerate}

\item Rebuild our application with the \code{-g} flag.

\item Rebuild the Buildroot system with debugging symbols, so that
  shared libraries have debugging symbols. However, since we don't
  want to rebuild the entire Buildroot system now, we'll use a trick
  and rebuild only the library we need to have the debugging symbols
  for: \code{libconfig}. To achieve this, first go to Buildroot
  \code{menuconfig}, and in \code{Build options}, enable
  \code{build packages with debugging symbols}. Then, do \code{make
    libconfig-dirclean all} to force the rebuild of just
  \code{libconfig}.

\end{enumerate}

Now, on your target, start {\em gdbserver} in multi-process mode,
listening on TCP port 2345:

\begin{verbatim}
gdbserver --multi localhost:2345
\end{verbatim}

Back on the host, run the cross-gdb with the \code{myapp} application
as argument:

\begin{verbatim}
arm-linux-gnueabihf-gdb myapp
\end{verbatim}

We need to tell \code{gdb} where the libraries can be found:

{\scriptsize
\begin{verbatim}
(gdb) set solib-search-path output/staging/lib:output/staging/lib/arm-linux-gnueabihf/: \
   output/staging/usr/lib:output/staging/usr/lib/arm-linux-gnueabihf/
\end{verbatim}
}

  (Note: this should be on one line, without spaces between each
  library path. We only had to cut the line here to make it fit in the
  document.)

And then connect to the target:

\begin{verbatim}
(gdb) target extended-remote 192.168.0.2:2345
\end{verbatim}

Define which program we want to run on the target:

\begin{verbatim}
(gdb) target remote exec-file myapp
\end{verbatim}

Let's put a breakpoint on the \code{main} function, and start the
program:

\begin{verbatim}
(gdb) break main
(gdb) run
\end{verbatim}

It stops on the first line of the \code{main} function, which is the
call to \code{config_init}, implemented by the \code{libconfig}
library. If you do the {\em gdb} instruction \code{step}, {\em gdb}
will step into the function, so you can follow what happens. After
having done \code{step} once, you can do \code{backtrace} to see that
you are in the function \code{config_init} called by \code{main}:

\begin{verbatim}
(gdb) backtrace
#0  config_init (config=0xbefffc3c) at libconfig.c:725
#1  0x000106f0 in main () at myapp.c:11
\end{verbatim}

Note that if you want \code{gdbserver} to stop on the target, you need
to run the {\em gdb} command \code{monitor exit}.

\section{Use {\tt <pkg>\_OVERRIDE\_SRCDIR}}

Now, let's say we have a more realistic application than a single
source file application: this application will have its own build
system ({\em Makefile}, {\em autotools}, etc.) and will also be
packaged in Buildroot because the application is part of the final
system.

The \code{<pkg>_OVERRIDE_SRCDIR} mechanism allows to tell Buildroot to
not use the download location indicated in the \code{.mk} file, but a
custom, local, directory instead.

In the {\em Advanced packaging} lab, we created a package for an
application called \code{bar}. Our \code{bar} package downloads the
application source code as a tarball from an HTTP server, and builds
it.

However, since we now want to do some active development on this
application, we want to tell Buildroot to use a custom location. In
the same lab, you did a Git clone of the \code{bar} Git repository, so
we will simply point Buildroot to this clone location. In your
Buildroot external tree (\code{BR2_EXTERNAL}), create a file called
\code{local.mk} that contains:

\begin{verbatim}
BAR_OVERRIDE_SRCDIR = $(HOME)/bar
\end{verbatim}

Now, adjust the \code{BR2_PACKAGE_OVERRIDE_FILE} configuration option
to \code{$(BR2_EXTERNAL)/local.mk} so that Buildroot reads your
\code{local.mk} file from your \code{BR2_EXTERNAL} tree.

Then, force the complete rebuild of the \code{bar} package:

\begin{verbatim}
make bar-dirclean all
\end{verbatim}

You should see as the first step being done that the \code{bar} source
code, instead of being extracted from a tarball, gets {\em rsynced}
from \code{$(HOME)/bar}:

\begin{verbatim}
>>> bar custom Syncing from source dir /home/thomas/bar
\end{verbatim}

However, the {\em configure} step fails, because the Git repository
doesn't contain a pre-generated configure script. So go to
\code{$HOME/bar} and run \code{autoreconf -i}.

Restart the compilation of the \code{bar} package from the {\em
  configure} step by running \code{make bar-reconfigure}. Notice how
it {\em rsyncs} the code again.

The build should now proceed to the end. Now, make a stupid but
visible change to \code{src/main.c}, such as:

\begin{verbatim}
-               printf("%d\n", result);
+               printf("==> %d\n", result);
\end{verbatim}

Restart the build of \code{bar} using \code{make bar-rebuild}, and
then scp the file \code{output/target/usr/bin/bar} to
\code{192.168.0.2:/usr/bin} and run \code{bar} again on the target.

As you can see you can now develop your applications and libraries,
using your normal version control system and relying on Buildroot to
do all the configure, build and install steps for you.

\section{Use the Eclipse IDE with Buildroot}

Download Eclipse Luna from
\url{http://www.eclipse.org/downloads/packages/eclipse-ide-cc-developers/lunar},
either the 32 bits or 64 bits Linux version depending on your
installation. Extract the downloaded tarball to your home folder, and
then start \code{eclipse} from the newly created \code{$HOME/eclipse/}
folder.

Follow the instructions at
\url{https://github.com/mbats/eclipse-buildroot-bundle/wiki/Tutorial-:-How-to-activate-and-install-the-Buildroot-Eclipse-plugin-%3F}
to install the Buildroot plugin.

Once the Buildroot plugin is installed, we need to adjust our Buildroot configuration so that it works properly with Eclipse:

\begin{enumerate}

\item We need to tell Buildroot to generate a small configuration file
  to let Eclipse know which toolchains are available. To do this, run
  the Buildroot \code{menuconfig}, and in the \code{Toolchain} menu,
  enable the option \code{Register toolchain within Eclipse Buildroot
    plug-in}.

\item We need to have a SFTP server, which Eclipse will use to upload
  application binaries. The most lightweight option is to enable
  \code{gesftpserver} in Buildroot.

\end{enumerate}

Run Buildroot's \code{make} command. After this, you should have a
\code{$HOME/.buildroot-eclipse-toolchains} file. Reflash your system
which now has {\em gesftpserver}, and also restart Eclipse.

Then, follow the instructions at
\url{https://github.com/mbats/eclipse-buildroot-bundle/wiki/Tutorial-:-How-to-create-a-new-C-project-using-the-Buildroot-toolchain-%3F}
to create a new C project, and then the instructions at
\url{https://github.com/mbats/eclipse-buildroot-bundle/wiki/Tutorial-:-How-to-execute-a-remote-application-%3F}
to run your application on the target.
