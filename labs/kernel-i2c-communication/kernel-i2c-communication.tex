\subchapter{Using the I2C bus}{Objective: make the I2C bus work and
use it to implement communication with the Nunchuk device}

After this lab, you will be able to:

\begin{itemize}
\item Declare pinctrl settings
\item Access I2C device registers through the bus
\end{itemize}

\section{Setup}

Stay in the \code{~/felabs/linux/src/linux} directory for kernel and DTB
compiling (stay in the \code{nunchuk} branch), and in
\code{~/felabs/linux/modules/nfsroot/nunchuk} for module compiling
(use two different terminals).

\section{Add pinctrl properties to the Device Tree}

As you found in the previous lab, we now managed to have our nunchuk
device enumerated on the \code{i2c1} bus.

However, to access the bus data and clock signals, we need to configure
the pin muxing of the SoC.

If you go back to the BeagleBone Black System Reference Manual, in the
{\em Connector P9} section, you can see that the pins \code{17} and
\code{18} that we are using correspond to pins \code{A16} and \code{B16}
of the AM335 SoC. You can also see that such pins need to be configured 
as \code{MODE2} to get the functionality that we need (\code{I2C1_SCL}
and \code{I2C1_SDA}).

Now look at the Device Tree for the AM335x EVM board
(\code{arch/arm/boot/dts/am335x-evm.dts}). It's using \code{i2c1} too.

Edit the \code{arch/arm/boot/dts/am335x-bone-common.dtsi} file and 
add what's needed to enable pin muxing for \code{i2c1}.
Don't hesitate to go back to the lectures to understand what to do!
