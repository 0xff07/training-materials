\subchapter{Build the system}{Objective: compile the root filesystem.}

After this lab, you will have a ready to use root filesystem to boot
your system with, including a video player application.

We haven't compiled the bootloader and kernel for our board yet,
but since this part can take a long time (especially compiling the
cross-compiling toolchain), let's start it now, while we are still
fetching kernel sources or going through lectures.

\section{Setup}

As specified in the Buildroot
manual\footnote{\url{https://buildroot.org/downloads/manual/manual.html\#requirement-mandatory}},
Buildroot requires a few packages to be installed on your
machine. Let's install them using Ubuntu's package manager:

\begin{verbatim}
sudo apt install sed make binutils gcc g++ bash patch \
  gzip bzip2 perl tar cpio python unzip rsync wget libncurses-dev
\end{verbatim}

\section{Choosing a Buildroot release}

Buildroot is one of the best tools for building a custom root filesystem
for a dedicated embedded system with a fixed set of features, typically
like the one we're trying to build.

Go to the /code{~/boot-time-labs/src/buildroot/} directory.

We will use the latest revision of the \code{2019.02} release, which is
one of Buildroot's long term releases:

\begin{verbatim}
git tag | grep 2019.02
git checkout 2019.02.2
\end{verbatim}

\section{Configuring Buildroot}

To minimize external dependencies and maximize flexibility, we will ask
Buildroot to generate its own toolchain. This can be better than using
external toolchains, as we have the ability to tweak toolchain settings
in a fine way if needed.

Start the Buildroot configuration utility:

\begin{verbatim}
make menuconfig
\end{verbatim}

\begin{itemize}
\item \code{Target Options} menu
  \begin{itemize}

  \item It is quite well known that the BeagleBone Black Wireless is
    an ARM based platform, so select \code{ARM (little endian)} as the
    target architecture.

  \item According to the BeagleBone Black Wireless website at
    \url{http://beagleboard.org/BLACK}, it uses a Texas Instruments
    AM335x, which is based on the ARM Cortex-A8 core. So select
    \code{cortex-A8} as the \code{Target Architecture Variant}.

  \item On ARM two {\em Application Binary Interfaces} are available:
    \code{EABI} and \code{EABIhf}. Unless you have backward
    compatibility concerns with pre-built binaries, \code{EABIhf} is
    more efficient, so make this choice as the \code{Target ABI}
    (which should already be the default anyway).

  \item The other parameters can be left to their default value:
    \code{ELF} is the only available \code{Target Binary Format},
    \code{VFPv3-D16} is a sane default for the {\em Floating Point
      Unit}, and using the \code{ARM} instruction set is also a good
    default (we could use the \code{Thumb-2} instruction set for
    slightly more compact code).





