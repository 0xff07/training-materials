\subchapter{Kernel optimizations}{Measure kernel boot components and
optimize the kernel boot time}

\section{Measuring}

We are going to use the kernel \code{initcall_debug} functionality.

Our default kernel already has the configuration settings that we need:
\begin{itemize}
\item \code{CONFIG_PRINTK_TIME=y}, to add a timestamp to each kernel
message.
\item \code{CONFIG_LOG_BUF=16}, to have a big enough kernel ring buffer.
\end{itemize}

That's not sufficient. We also need the output of the \code{dmesg}
command. Temporarily add support for this command in BusyBox,
and add the below line after the \code{ffmpeg} file in the
\code{playvideo} scripts:

\begin{verbatim}
dmesg > /dev/console
\end{verbatim}

Run Buildroot again, and update your
\code{~/boot-time-labs/rootfs/rootfs} directory again. Compile your
kernel again to to update the \code{zImage} with this root filesystem.

Now, let's enable \code{initcall_debug} in kernel parameters. Go to
the U-Boot command line, and add the below settings to the kernel command line
\footnote{Don't save these settings with \code{saveenv}. We
will just need them once.}, and boot your system:
\begin{verbatim}
setenv bootargs ${bootargs} initcall_debug printk.time=1
boot
\end{verbatim}

Boot the board with the new kernel image. If everything went well,
you can now copy and paste the special \code{dmesg} output to
a \code{~/boot-time-labs/kernel/initcall_debug.log} file on your workstation.

In \code{~/boot-time-labs/kernel} (at least where the kernel sources
are), run the following command to generate a boot graph:

\begin{verbatim}
linux/scripts/bootgraph.pl initcall_debug.log > boot.svg
\end{verbatim}

You can view the boot graph with the \code{inkscape} vector graphics
editor:

\begin{verbatim}
sudo apt install inkscape
inkscape boot.svg
\end{verbatim}

\begin{center}
\includegraphics[width=\textwidth]{labs/boot-time-kernel/boot.pdf}
\end{center}

Now review the longuest initcalls in detail. Each label is the name of
a function in the kernel sources. Try to find out in which source file
each function is defined\footnote{You can do it with utilities such as
\code{cscope}, which your instructor will be happy to demonstrate,
or through our on-line service to explore the Linux kernel sources:
\url{https://elixir.bootlin.com}}, and what each driver corresponds
to.

Then, you can look the source code and try look for obvious causes which
would explain the very long execution time: delay loops (look for
\code{delay}, parameters which can reduce probe time but are not used,
etc).

Remove \code{dmesg} support from BusyBox and remove this command too
from \code{playvideo}. Update your root filesystem and then kernel so
that we get back to the original situation. We should just need to use
\code{initcall_debug} once.

\section{Reordering and postponing functionality}

In our case, we are only going to keep kernel features that we will need
to run our video player. However, in a real life system, the boot graph
could reveal drivers which could be compiled as modules
and loaded later.

\section{Removing unnecessary functionality}

The boot graph that we generated doesn't show any obvious kernel
driver that would consume a significant amount of time and could be
taken away because it is completely useless.

Of course, there will be kernel features that we will be able to remove,
in order to reduce the kernel size and make the kernel faster to load
in the bootloader. However, this shouldn't have much impact on the
kernel's execution time.

There's one thing we can remove though, and didn't appear on the boot
graph: we can disable console output. Writing messages on the serial
line can be very slow, especially as the serial line has a slow
bandwidth.

You can do this by adding the \code{quiet} parameter to the kernel
command line. Since we reflash the device frequently, let's store
the new setting in the flashing script.

Look for the \code{bootargs} setting in the
\code{sama5d3x_demo_linux_nandflash.tcl} file and add the \code{quiet}
parameter.

Reflash your device, measure boot time, and write in down in the summary
table.

There is another thing that is unnecessary too: the calibration of the
delay loop, as explained in the lectures. Read the \code{lpj} value from
a previous boot log, and pass this value on the kernel command line.

Measure the new boot time and write your result in the summary table.

\section{Optimizing necessary functionality}

The boot graph revealed the existence of drivers with initcalls taking a
long time to execute. It would
be worth spending time analysing their code, looking for opportunities to
reduce the initialization time taken by these drivers.

However, such investigation work could take days, unless you find
obvious issues (such as big delay loops).

