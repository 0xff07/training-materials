\setbeamerfont{block title}{size=\scriptsize}

\section{Application development}

\begin{frame}{Building code for Buildroot}
  \begin{itemize}
  \item The Buildroot cross-compiler is installed in
    \code{$(HOST_DIR)/usr/bin}
  \item It is already set up to:
    \begin{itemize}
    \item generate code for the configured architecture
    \item look for libraries and headers in \code{$(STAGING_DIR)}
    \end{itemize}
  \item Other useful tools that may be built by Buildroot are
    installed in \code{$(HOST_DIR)/usr/bin}:
    \begin{itemize}
    \item \code{pkg-config}, to find libraries. Beware that it is
      configured to return results for {\em target} libraries: it
      should only be used when cross-compiling.
    \item \code{qmake}, when building Qt applications with this build
      system.
    \item \code{autoconf}, \code{automake}, \code{libtool}, to use
      versions independent from the host system.
    \end{itemize}
  \item Adding \code{$(HOST_DIR)/usr/bin} to your \code{PATH} when
    cross-compiling is the easiest solution.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Building code for Buildroot: C program}

\begin{block}{Building a C program for the host}
{\small
  \begin{verbatim}
$ gcc -o foobar foobar.c
$ file foobar
foobar: ELF 64-bit LSB executable, x86-64, version 1...
\end{verbatim}}
\end{block}

\begin{block}{Building a C program for the target}
{\small
  \begin{verbatim}
$ export PATH=$(pwd)/output/host/usr/bin:$PATH
$ arm-linux-gcc -o foobar foobar.c
$ file foobar
foobar: ELF 32-bit LSB executable, ARM, EABI5 version 1...
\end{verbatim}}
\end{block}

\end{frame}

\begin{frame}[fragile]{Building code for Buildroot: pkg-config}

  \begin{block}{Using the system \code{pkg-config}}
{\small
\begin{verbatim}
$ pkg-config --cflags libpng
-I/usr/include/libpng12

$ pkg-config --libs libpng
-lpng12
\end{verbatim}}
  \end{block}

  \begin{block}{Using the Buildroot \code{pkg-config}}
{\small
\begin{verbatim}
$ export PATH=$(pwd)/output/host/usr/bin:$PATH

$ pkg-config --cflags libpng
-I.../output/host/usr/arm-buildroot-linux-uclibcgnueabi/
    sysroot/usr/include/libpng16

$ pkg-config --libs libpng
-L.../output/host/usr/arm-buildroot-linux-uclibcgnueabi/
    sysroot/usr/lib -lpng16
\end{verbatim}}
  \end{block}

{\tiny Note: too long lines have been splitted.}

\end{frame}

\begin{frame}[fragile]{Building code for Buildroot: autotools}
  \begin{itemize}
  \item Building simple {\em autotools} components outside of
    Buildroot is easy:
    \begin{block}{}
{\small
\begin{verbatim}
$ export PATH=.../buildroot/output/host/usr/bin/:$PATH
$ ./configure --host=arm-linux
\end{verbatim}}
\end{block}
\item Passing \code{--host=arm-linux} tells the configure script to
  use the cross-compilation tools prefixed by \code{arm-linux-}.
\item In more complex cases, some additional \code{CFLAGS} or
  \code{LDFLAGS} might be needed in the environment.
  \end{itemize}
\end{frame}

\begin{frame}{The {\tt <pkg>\_OVERRIDE\_SRCDIR} mechanism}
  \begin{itemize}
  \item Very often, you don't build packages manually: Buildroot
    builds them for you.
  \item But Buildroot also downloads them for you, and keeps the
    source code in the package build directory.
  \item Not very practical during development:
    \begin{itemize}
    \item The build directory is temporary, gets removed when doing a
      \code{make clean} or \code{make <pkg>-dirclean}
    \item The build directory isn't checked out from your version
      control system.
    \end{itemize}
  \item Buildroot should, for certain packages, pick up the source
    from a local directory.
  \item This is exactly what \code{<pkg>\_OVERRIDE\_SRCDIR} allows to
    do.
  \end{itemize}
\end{frame}

\begin{frame}{Without {\tt <pkg>\_OVERRIDE\_SRCDIR}}
  \begin{itemize}
  \item The normal package build process, when
    \code{<pkg>_OVERRIDE_SRCDIR} is not used, is:
    \begin{enumerate}
    \item Package gets downloaded as a tarball, or from a VCS
      repository (in which case a tarball is generated)
    \item The tarball is extracted in
      \code{$(O)/build/<pkg>-<version>}
    \item Then the configure, build and installs steps are executed
    \end{enumerate}
  \item \code{$(O)/build/<pkg>-<version>/} does not contain any VCS
    metadata, and is a temporary directory.
  \item Running \code{make <pkg>-reconfigure}, \code{make
      <pkg>-rebuild}, \code{make <pkg>-reinstall} only restarts the
    build process from one of the corresponding steps.
  \end{itemize}
\end{frame}

\begin{frame}{Effect of {\tt <pkg>\_OVERRIDE\_SRCDIR}}
  \begin{itemize}
  \item For each package, you can define a
    \code{<pkg>_OVERRIDE_SRCDIR} variable that points to a local
    directory containing the source code for this package.
  \item Instead of downloading and extracting the original source,
    Buildroot will {\em rsync} the source from the specified directory
    to the build directory.
  \item Invoking \code{make <pkg>-reconfigure}, \code{make
      <pkg>-rebuild}, \code{make <pkg>-reinstall} will retrigger a
    {\em rsync}.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Passing {\tt <pkg>\_OVERRIDE\_SRCDIR}}
  \begin{itemize}
  \item \code{<pkg>_OVERRIDE_SRCDIR} can be specified:
    \begin{itemize}
    \item In the package \code{.mk} file itself. Not ideal solution,
      and identical to \code{<pkg>_SITE_METHOD = local}
    \item In a {\em package override file}, configured in
      \code{BR2_PACKAGE_OVERRIDE_FILE}, by default
      \code{$(CONFIG_DIR)/local.mk.}
    \end{itemize}
  \end{itemize}

  \begin{block}{Example \code{local.mk}}
\begin{minted}{make}
LIBPNG_OVERRIDE_SRCDIR = $(HOME)/projects/libpng
LINUX_OVERRIDE_SRCDIR = $(HOME)/projects/linux
\end{minted}
  \end{block}
\end{frame}

\begin{frame}{{\tt <pkg>\_OVERRIDE\_SRCDIR} workflow}
  \begin{center}
    \includegraphics[height=0.8\textheight]{slides/buildroot-appdev/override-srcdir.pdf}
  \end{center}
\end{frame}

\begin{frame}{Debugging: debugging symbols and stripping}
  \begin{itemize}
  \item To use debuggers, you need the programs and libraries to be
    built with debugging symbols.
  \item The \code{BR2_ENABLE_DEBUG} option controls whether programs
    and libraries are built with debugging symbols
    \begin{itemize}
    \item Disabled by default.
    \item Sub-options allow to control the amount of debugging symbols
      (i.e gcc options \code{-g1}, \code{-g2} and \code{-g3}).
    \end{itemize}
  \item The \code{BR2_STRIP_none} and \code{BR2_STRIP_strip} options
    allow to disable or enable stripping of binaries on the target.
  \end{itemize}
\end{frame}

\begin{frame}{Debugging: debugging symbols and stripping}
  \begin{itemize}
  \item With \code{BR2_ENABLE_DEBUG=y} and \code{BR2_STRIP_strip=y}
    \begin{itemize}
    \item get debugging symbols in \code{$(STAGING_DIR)} for
      libraries, and in the build directories for everything.
    \item stripped binaries in \code{$(TARGET_DIR)}
    \item Appropriate for {\bf remote debugging}
    \end{itemize}
  \item With \code{BR2_ENABLE_DEBUG=y} and \code{BR2_STRIP_none=y}
    \begin{itemize}
    \item debugging symbols in both \code{$(STAGING_DIR)} and
      \code{$(TARGET_DIR)}
    \item appropriate for {\bf on-target debugging}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Debugging: remote debugging requirements}
  \begin{itemize}
  \item To do remote debugging, you need:
    \begin{itemize}
    \item A {\bf cross-debugger}
      \begin{itemize}
      \item With the {\em internal toolchain backend}, can be built
        using \code{BR2_PACKAGE_HOST_GDB=y}.
      \item With the {\em external toolchain backend}, is either
        provided pre-built by the toolchain, or can be built using
        \code{BR2_PACKAGE_HOST_GDB=y}.
      \end{itemize}
    \item {\bf gdbserver}
      \begin{itemize}
      \item With the {\em internal toolchain backend}, can be built
        using \code{BR2_PACKAGE_GDB=y} + \code{BR2_PACKAGE_GDB_SERVER=y}
      \item With the {\em external toolchain backend}, if
        \code{gdbserver} is provided by the toolchain it can be copied
        to the target using
        \code{BR2_TOOLCHAIN_EXTERNAL_GDB_SERVER_COPY=y} or otherwise
        built from source like with the internal toolchain backend.
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Debugging: remote debugging setup}
  \begin{itemize}
  \item On the target, start {\em gdbserver}
    \begin{itemize}
    \item Use a TCP socket, network connectivity needed
    \item The {\em multi} mode is quite convenient
    \item \code{$ gdbserver --multi localhost:2345}
    \end{itemize}
  \item On the host, start \code{<tuple>-gdb}
    \begin{itemize}
    \item \code{$ ./output/host/usr/bin/<tuple>-gdb <program>}
    \item \code{<program>} is the path to the program to debug, with
      debugging symbols
    \end{itemize}
  \item Inside {\em gdb}, you need to:
    \begin{itemize}
    \item Connect to the target:\\
      \code{(gdb) target remote-extended <ip>:2345}
    \item Set the path to the {\em sysroot} so that {\em gdb} can find debugging symbols for libraries:\\
      \code{(gdb) set sysroot ./output/staging/}
    \item Start the program:\\
      \code{(gdb) run}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Debugging tools available in Buildroot}
  \begin{itemize}
  \item Buildroot also includes a huge amount of other debugging or
    profiling related tools.
  \item To list just a few:
    \begin{itemize}
    \item strace
    \item ltrace
    \item LTTng
    \item perf
    \item sysdig
    \item sysprof
    \item OProfile
    \item valgrind
    \end{itemize}
  \item Look in \code{Target packages} $\rightarrow$ \code{Debugging,
      profiling and benchmark} for more.
  \end{itemize}
\end{frame}

\begin{frame}{Generating a SDK for application developers}
  \begin{itemize}
  \item If you would like application developers to build applications
    for a Buildroot generated system, without building Buildroot, you
    can generate a SDK.
  \item To achieve this:
    \begin{itemize}
    \item Customize the \code{BR2_HOST_DIR} option to a path like
      \code{/opt/project-sdk/}.
    \item Do a full build from scratch. Due to the value of
      \code{BR2_HOST_DIR}, the cross-compiler and the sysroot with all
      its libraries will be installed in \code{/opt/project-sdk/}
      instead of the normal \code{$(O)/host}.
    \item Tarball the \code{/opt/project-sdk/} and share it with the
      developers.
    \end{itemize}
  \item Warnings:
    \begin{itemize}
    \item The SDK is not relocatable: it must remain in
      \code{/opt/project-sdk/}
    \item The SDK must remain in sync with the root filesystem running
      on the target, otherwise applications built with the SDK may not
      run properly.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Eclipse plug-in}
  \begin{itemize}
  \item For application developers interested in using the Eclipse
    IDE, a Buildroot-specific plugin has been developed.
  \item It integrates the toolchain(s) generated by Buildroot into the
    Eclipse C/C++ Development Environment.
  \item Allows Eclipse projects to easily use the compiler, linker and
    debugger provided by Buildroot
  \item In Buildroot, enable the \code{BR2_ECLIPSE_REGISTER} option.
  \item In Eclipse, install the {\em Buildroot} plugin, and follow the
    instructions available from the plugin website.
  \item See
    \url{https://github.com/mbats/eclipse-buildroot-bundle/wiki} for
    download, installation and usage details.
  \end{itemize}
\end{frame}

\setuplabframe
{Application development}
{
  \begin{itemize}
  \item Build and run your own application
  \item Remote debug your application
  \item Use \code{<pkg>_OVERRIDE_SRCDIR}
  \item Set up Eclipse for Buildroot application development
  \end{itemize}
}
