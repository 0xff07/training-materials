\begin{frame}
  \frametitle{Porting the Linux kernel}
  \begin{itemize}
  \item The Linux kernel supports a lot of different CPU architectures
  \item Each of them is maintained by a different group of
    contributors
    \begin{itemize}
    \item See the \code{MAINTAINERS} file for details
    \end{itemize}
  \item The organization of the source code and the methods to port
    the Linux kernel to a new board are therefore very
    architecture-dependent
    \begin{itemize}
    \item For example, some architectures use the Device Tree, some do
      not.
    \end{itemize}
  \item This presentation is focused on the ARM architecture only
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Architecture, CPU and Machine}
  \begin{itemize}
  \item In the source tree, each architecture has its own directory
    \begin{itemize}
    \item \code{arch/arm} for the ARM architecture
    \end{itemize}
  \item This directory contains generic ARM code
    \begin{itemize}
    \item \code{boot}, \code{common}, \code{configs}, \code{kernel},
      \code{lib}, \code{mm}, \code{nwfpe}, \code{vfp},
      \code{oprofile}, \code{tools}
    \end{itemize}
  \item And many directories for different SoC families
    \begin{itemize}
    \item \code{mach-*} directories: \code{mach-pxa} for PXA CPUs,
      \code{mach-imx} for Freescale iMX CPUs, etc.
      \begin{itemize}
      \item Before the ARM cleanup, those directories contained
        support for the SoC family (GPIO, clocks, pinmux, power
        management, interrupt controller, etc.) and for the various
        boards.
      \item Nowadays, they contain a lot less code, essentially a
        small SoC description file, power management and SMP code.
      \end{itemize}
    \end{itemize}
  \item Some CPU types share some code, in directories named
    \code{plat-*}
  \item Device Tree files in \code{arch/arm/boot/dts}.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Before the Device Tree and ARM cleanup}
  \begin{itemize}
  \item Until 2011, the ARM architecture wasn't using the Device Tree,
    and a large portion of the SoC support was located in
    \code{arch/arm/mach-<foo>}.
  \item Each board supported by the kernel was associated to an unique
    {\em machine ID}.
  \item The entire list of {\em machine ID} can be downloaded at
    \url{http://www.arm.linux.org.uk/developer/machines/download.php}
    and one could freely register an additional one.
  \item The Linux kernel was defining a {\em machine structure} for
    each board, which associates the {\em machine ID} with a set of
    informations and callbacks.
  \item The bootloader had to pass the {\em machine ID} to the kernel
    in a specific ARM register.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The Device Tree and the ARM cleanup}
  \begin{itemize}
  \item As the ARM architecture gained significantly in popularity,
    some major refactoring was needed.
  \item First, the Device Tree was introduced on ARM: instead of using
    C code to describe SoCs and boards, a specialized language is
    used.
  \item Second, many driver infrastructures were created to replace
    custom code in \code{arch/arm/mach-<foo>}:
    \begin{itemize}
    \item The common clock framework in \code{drivers/clk}
    \item The pinctrl subsystem in \code{drivers/pinctrl}
    \item The irqchip subsystem in \code{drivers/irqchip}
    \item The clocksource subsystem in \code{drivers/clocksource}
    \end{itemize}
  \item The amount of code in \code{mach-<foo>} has now significantly
    reduced.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Adding the support for a new ARM board}
  Provided the SoC used on your board is supported by the Linux kernel:
  \begin{enumerate}
  \item Create a {\em Device Tree} file in \code{arch/arm/boot/dts},
    generally named \code{<soc-name>-<board-name>.dts}, and make it
    include the relevant SoC \code{.dtsi} file.
    \begin{itemize}
    \item Your Device Tree will describe all the SoC peripherals that
      are enabled, the pin muxing, as well as all the devices on the
      board.
    \end{itemize}
  \item Modify \code{arch/arm/boot/dts/Makefile} to make sure your
    Device Tree gets built as a {\em DTB} during the kernel build.
  \item If needed, develop the missing device drivers for the devices
    that are on your board outside the SoC.
  \end{enumerate}
\end{frame}

\begin{frame}
  \frametitle{Example of the Marvell Armada 370/XP SoCs}
  \begin{itemize}
  \item The hardware platform used in this training is based on the
    AM335x processor from Texas Instruments.
  \item This platform inherits from the OMAP family of TI, for which
    kernel support has been around for a long time.
  \item Due to this, and the complexity of the platform, the AM335x
    and OMAP support in the kernel hasn't fully migrated yet to all
    the infrastructures created during the {\em ARM cleanup}.
  \item Therefore, to illustrate this section, we will take the
    example of the Marvell Armada 370/XP platform, on which Free
    Electrons has worked specifically.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Studying the OpenBlocks AX3-4 platform}
  \begin{columns}
    \column{0.7\textwidth}
    \begin{itemize}
    \item OpenBlocks AX3-4
    \item Uses the dual-core Marvell Armada MV78260, from the Armada
      XP family.
    \item 1 GB of RAM
    \item 4 Gigabit Ethernet ports
    \item 2 serial ports, one button, 3 LEDS
    \item Two I2Cs bus, one equipped with a RTC
    \item Two SATA ports, one internal, one external
    \item Two USB ports
    \item One mini-PCIe connector
    \item One 128 MB NOR flash
    \end{itemize}
    \column{0.3\textwidth}
    \includegraphics[width=\textwidth]{slides/kernel-porting-content/openblocks.jpg}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{OpenBlocks AX3-4 Device Tree, header}
  \begin{itemize}
  \item Mandatory Device Tree language definition\\
    \begin{block}{} \mint[fontsize=\tiny]{perl}+/dts-v1/+ \end{block}
  \item Include the \code{.dtsi} file describing the SoC\\
    \begin{block}{} \mint[fontsize=\tiny]{perl}+#include "armada-xp-mv78260.dtsi"+ \end{block}
  \item Start the root of the tree\\
    \begin{block}{} \mint[fontsize=\tiny]{perl}+/ {+ \end{block}
  \item A human-readable string to describe the machine\\
    \begin{block}{} \mint[fontsize=\tiny]{perl}+  model = "PlatHome OpenBlocks AX3-4 board";+ \end{block}
  \item A list of {\em compatible} strings, from the most specific one
    to the most general one. Can be used by kernel code to do a SoC or
    board-specific check.\\
    \begin{block}{}
    \begin{minted}[fontsize=\tiny]{perl}
    compatible = "plathome,openblocks-ax3-4",
        "marvell,armadaxp-mv78260", "marvell,armadaxp",
        "marvell,armada-370-xp";
      \end{minted}
    \end{block}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{OpenBlocks AX3-4 Device Tree, chosen/memory}
  \begin{itemize}
  \item Definition of the default {\em kernel command line}. Some
    additional operating-system specific entries can be added in
    \code{chosen}:
    \begin{block}{}
    \begin{minted}[fontsize=\footnotesize]{perl}
chosen {
        bootargs = "console=ttyS0,115200 earlyprintk";
};
\end{minted}
\end{block}
\item Definition of the size and location of the RAM:
  \begin{block}{}
    \begin{minted}[fontsize=\footnotesize]{perl}
memory {
        device_type = "memory";
        reg = <0 0x00000000 0 0xC0000000>; /* 3 GB */
};
      \end{minted}
    \end{block}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{OpenBlocks AX3-4 Device Tree, bus/PCIe}
  \begin{itemize}
  \item Start of the internal SoC peripherals. The \code{ranges}
    property has a special meaning for the Marvell platforms: it
    allows to configure special memory windows dedicated to some
    peripherals.
    \begin{block}{}
    \begin{minted}[fontsize=\tiny]{perl}
soc {
        ranges = <MBUS_ID(0xf0, 0x01) 0 0 0xd0000000 0x100000
                  MBUS_ID(0x01, 0x1d) 0 0 0xfff00000 0x100000
                  MBUS_ID(0x01, 0x2f) 0 0 0xf0000000 0x8000000>;
\end{minted}
\end{block}
\item The OpenBlocks has one internal mini-PCIe connector, so the
  corresponding PCIe interface is enabled:
  \begin{block}{}
    \begin{minted}[fontsize=\tiny]{perl}
                pcie-controller {
                        status = "okay";
                        /* Internal mini-PCIe connector */
                        pcie@1,0 {
                                /* Port 0, Lane 0 */
                                status = "okay";
                        };
                };
    \end{minted}
  \end{block}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{OpenBlocks AX3-4 Device Tree, NOR flash}
\begin{itemize}
\item Definition of the {\em device bus} timings, where a NOR flash is
  connected:
  \begin{block}{}
    \begin{minted}[fontsize=\tiny]{perl}
        devbus-bootcs {
                status = "okay";

                /* Read parameters */
                devbus,bus-width    = <8>;
                devbus,turn-off-ps  = <60000>;
                [...]

                /* Write parameters */
                devbus,sync-enable = <0>;
                devbus,wr-high-ps  = <60000>;
                [...]

                /* NOR 128 MiB */
                nor@0 {
                        compatible = "cfi-flash";
                        reg = <0 0x8000000>;
                        bank-width = <2>;
                };
        };
      \end{minted}
    \end{block}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{OpenBlocks AX3-4 Device Tree, serial/muxing}
\begin{itemize}
\item There are two serial ports available:
  \begin{block}{}
    \begin{minted}[fontsize=\tiny]{perl}
                internal-regs {
                        serial@12000 {
                                clock-frequency = <250000000>;
                                status = "okay";
                        };
                        serial@12100 {
                                clock-frequency = <250000000>;
                                status = "okay";
                        };
    \end{minted}
    \end{block}
  \item Definition of a few pins that will be muxed as GPIO, for LEDs.
  \begin{block}{}
    \begin{minted}[fontsize=\tiny]{perl}
                        pinctrl {
                                led_pins: led-pins-0 {
                                        marvell,pins = "mpp49", "mpp51", "mpp53";
                                        marvell,function = "gpio";
                                };
                        };
    \end{minted}
  \end{block}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{OpenBlocks AX3-4 Device Tree, LEDs}
\begin{itemize}
\item Three LEDs are connected to this platform. Note the reference to
  the \code{led_pins} muxing configuration.
  \begin{block}{}
    \begin{minted}[fontsize=\tiny]{perl}
                        leds {
                                compatible = "gpio-leds";
                                pinctrl-names = "default";
                                pinctrl-0 = <&led_pins>;

                                red_led {
                                        label = "red_led";
                                        gpios = <&gpio1 17 1>;
                                        default-state = "off";
                                };

                                yellow_led {
                                        label = "yellow_led";
                                        gpios = <&gpio1 19 1>;
                                        default-state = "off";
                                };

                                green_led {
                                        label = "green_led";
                                        gpios = <&gpio1 21 1>;
                                        default-state = "off";
                                        linux,default-trigger = "heartbeat";
                                };
                        };
    \end{minted}
    \end{block}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{OpenBlocks AX3-4 Device Tree, button}
  \begin{itemize}
  \item The platform has one button connected to a GPIO. The
    \code{gpio-keys} driver makes the button appear as an {\em input
      device}.
    \begin{block}{}
      \begin{minted}[fontsize=\tiny]{perl}
                        gpio_keys {
                                compatible = "gpio-keys";
                                #address-cells = <1>;
                                #size-cells = <0>;

                                button@1 {
                                        label = "Init Button";
                                        linux,code = <116>;
                                        gpios = <&gpio1 28 0>;
                                };
                        };
    \end{minted}
    \end{block}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{OpenBlocks AX3-4 Device Tree, network}
  \begin{columns}[t]
    \column{0.5\textwidth} The network PHYs, with their address on the
    MDIO bus.
    \begin{block}{}
      \begin{minted}[fontsize=\tiny]{perl}
mdio {
        phy0: ethernet-phy@0 {
                reg = <0>;
        };

        phy1: ethernet-phy@1 {
                reg = <1>;
        };

        phy2: ethernet-phy@2 {
                reg = <2>;
        };

        phy3: ethernet-phy@3 {
                reg = <3>;
        };
};
    \end{minted}
    \end{block}
    \column{0.5\textwidth}
    The network interfacces themselves.
    \begin{block}{}
      \begin{minted}[fontsize=\tiny]{perl}
ethernet@70000 {
        status = "okay";
        phy = <&phy0>;
        phy-mode = "sgmii";
};
ethernet@74000 {
        status = "okay";
        phy = <&phy1>;
        phy-mode = "sgmii";
};
ethernet@30000 {
        status = "okay";
        phy = <&phy2>;
        phy-mode = "sgmii";
};
ethernet@34000 {
        status = "okay";
        phy = <&phy3>;
        phy-mode = "sgmii";
};
    \end{minted}
    \end{block}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{OpenBlocks AX3-4 Device Tree, I2C busses}
  \begin{itemize}
  \item A first I2C bus, with nothing connected on it:
    \begin{block}{}
      \begin{minted}[fontsize=\tiny]{perl}
                        i2c@11000 {
                                status = "okay";
                                clock-frequency = <400000>;
                        };
      \end{minted}
    \end{block}
  \item A second I2C bus, with a S35390A Real Time Clock connected to
    it:
    \begin{block}{}
      \begin{minted}[fontsize=\tiny]{perl}
                        i2c@11100 {
                                status = "okay";
                                clock-frequency = <400000>;

                                s35390a: s35390a@30 {
                                        compatible = "s35390a";
                                        reg = <0x30>;
                                };
                        };
      \end{minted}
    \end{block}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{OpenBlocks AX3-4 Device Tree, SATA/USB}
  \begin{itemize}
  \item A SATA unit, with two ports:
    \begin{block}{}
      \begin{minted}[fontsize=\tiny]{perl}
                        sata@a0000 {
                                nr-ports = <2>;
                                status = "okay";
                        };
      \end{minted}
    \end{block}
  \item Two USB interfaces:
    \begin{block}{}
      \begin{minted}[fontsize=\tiny]{perl}
                        /* Front side USB 0 */
                        usb@50000 {
                                status = "okay";
                        };

                        /* Front side USB 1 */
                        usb@51000 {
                                status = "okay";
                        };
      \end{minted}
    \end{block}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{OpenBlocks AX3-4: build the DTB}
  \begin{itemize}
  \item To ensure that the Device Tree Blob gets built for this board
    Device Tree Source, one need to ensure it is listed in
    \code{arch/arm/boot/dts/Makefile}:
    \begin{block}{}
      \begin{minted}{make}
dtb-$(CONFIG_ARCH_MVEBU) += armada-370-db.dtb \
        armada-370-mirabox.dtb \
        armada-370-netgear-rn102.dtb \
        armada-370-rd.dtb \
        armada-xp-axpwifiap.dtb \
        armada-xp-db.dtb \
        armada-xp-gp.dtb \
        armada-xp-openblocks-ax3-4.dtb
      \end{minted}
    \end{block}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Understanding the SoC support}
  \begin{itemize}
  \item For the Marvell Armada 370/XP platforms, the core of the SoC
    support is located in \code{arch/arm/mach-mvebu}
  \item The \code{armada-370-xp.c} (see code on the next slide)
    contains the "{\em entry point}" of the SoC definition, the
    \code{DT_MACHINE_START} .. \code{MACHINE_END} definition:
    \begin{itemize}
    \item Defines the list of platform compatible strings that will
      match this platform, in this case
      \code{marvell,armada-370-xp}. This allows the kernel to know
      which \code{DT_MACHINE} structure to use depending on the DTB
      that is passed at boot time.
    \item Defines various callbacks for the platform initialization,
      the most important one being the \code{.init_machine} callback,
      which calls \code{of_platform_populate()}. This function travels
      through the Device Tree and instantiate all the devices.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{{\tt arch/arm/mach-mvebu/armada-370-xp.c}}
  \begin{block}{}
    \begin{minted}[fontsize=\tiny]{c}
static void __init armada_370_xp_dt_init(void)
{
        of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
}

static const char * const armada_370_xp_dt_compat[] = {
        "marvell,armada-370-xp",
        NULL,
};

DT_MACHINE_START(ARMADA_XP_DT, "Marvell Armada 370/XP (Device Tree)")
        .smp            = smp_ops(armada_xp_smp_ops),
        .init_machine   = armada_370_xp_dt_init,
        .map_io         = armada_370_xp_map_io,
        .init_time      = armada_370_xp_timer_and_clk_init,
        .restart        = mvebu_restart,
        .dt_compat      = armada_370_xp_dt_compat,
MACHINE_END
  \end{minted}
 \end{block}
\end{frame}

\begin{frame}
  \frametitle{Components of the minimal SoC support}
  The minimal SoC support consists in
  \footnotesize
  \begin{itemize}
  \item An SoC {\em entry point} file,
    \code{arch/arm/mach-mvebu/armada-370-xp.c}
  \item At least one SoC \code{.dtsi} DT and one board \code{.dts} DT,
    in \code{arch/arm/boot/dts}
  \item A interrupt controller driver,
    \code{drivers/irqchip/irq-armada-370-xp.c}
  \item A timer driver,
    \code{drivers/clocksource/time-armada-370-xp.c}
  \item An earlyprintk implementation to get early messages from the
    console, \code{arch/arm/Kconfig.debug} and
    \code{arch/arm/include/debug}
  \item A serial port driver in \code{drivers/tty/serial}. For Armada
    370/XP, the 8250 driver \code{drivers/tty/serial/8250} is used.
  \end{itemize}
  \normalsize
  This allows to boot a minimal system up to userspace, using a root
  filesystem in {\em initramfs}.
\end{frame}

\begin{frame}
  \frametitle{Extending the minimal SoC support}

  Once the minimal SoC support is in place, the following core
  components should be added:
  \begin{itemize}
  \item Support for the clocks. Usually requires some clock drivers,
    as well as DT representations of the clocks. See
    \code{drivers/clk/mvebu} for Armada 370/XP clock drivers.
  \item Support for pin muxing, through the {\em pinctrl}
    subsystem. See \code{drivers/pinctrl/mvebu} for the Armada 370/XP
    drivers.
  \item Support for GPIOs, through the {\em GPIO} subsystem. See
    \code{drivers/gpio/gpio-mvebu.c} for the Armada 370/XP GPIO
    driver.
  \item Support for SMP, through the \code{smp_operations}. See
    \code{arch/arm/mach-mvebu/platsmp.c}.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Adding device drivers}
  Once the core pieces of the SoC support have been implemented, the
  remaining part is to add drivers for the different hardware blocks:
  \begin{itemize}
  \item Ethernet driver, in \code{drivers/net/ethernet/mvneta.c}
  \item SATA driver, in \code{drivers/ata/sata_mv.c}
  \item I2C driver, in \code{drivers/i2c/busses/i2c-mv64xxx.c}
  \item SPI driver, in \code{drivers/spi/spi-orion.c}
  \item PCIe driver, in \code{drivers/pci/host/pci-mvebu.c}
  \item USB driver, in \code{drivers/usb/host/ehci-orion.c}
  \item etc.
  \end{itemize}
\end{frame}