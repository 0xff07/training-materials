NAND support for IGEPv2 rev 6

Written by Wim Torfs <wim.torfs@ua.ac.be>

diff --git a/board/igep0020/igep0020.c b/board/igep0020/igep0020.c
index 941b3ad..8a0451d 100644
--- a/board/igep0020/igep0020.c
+++ b/board/igep0020/igep0020.c
@@ -24,6 +24,7 @@
 #include <common.h>
 #include <command.h>
 #include <part.h>
+#include <i2c.h>
 #include <fat.h>
 #include <asm/arch/cpu.h>
 #include <asm/arch/bits.h>
@@ -36,6 +37,14 @@
 #include <linux/mtd/onenand_regs.h>
 #include <linux/mtd/onenand.h>
 
+// GPIO_LED_USER0 (led red)
+#define GPIO_LED_USER0      27
+// GPIO_LED_USER1 (led green)
+#define GPIO_LED_USER1      26
+// GPIO_LED_USER2 (led power)
+#define GPIO_LED_USER2      28
+
+
 /* Used to index into DPLL parameter tables */
 struct dpll_param {
 	unsigned int m;
@@ -56,13 +65,15 @@ struct dpll_per_36x_param {
 	unsigned int m2div;
 };
 
+static u32 nand_mfr = 0;
+
 typedef struct dpll_param dpll_param;
 
 /* Following functions are exported from lowlevel_init.S */
-extern dpll_param *get_mpu_dpll_param();
-extern dpll_param *get_iva_dpll_param();
-extern dpll_param *get_core_dpll_param();
-extern dpll_param *get_per_dpll_param();
+extern dpll_param *get_mpu_dpll_param(void);
+extern dpll_param *get_iva_dpll_param(void);
+extern dpll_param *get_core_dpll_param(void);
+extern dpll_param *get_per_dpll_param(void);
 
 extern dpll_param *get_36x_mpu_dpll_param(void);
 extern dpll_param *get_36x_iva_dpll_param(void);
@@ -103,9 +114,7 @@ u32 get_device_type(void)
  ************************************************/
 u32 get_sysboot_value(void)
 {
-	int mode;
-	mode = __raw_readl(CONTROL_STATUS) & (SYSBOOT_MASK);
-	return mode;
+	return __raw_readl(CONTROL_STATUS) & (SYSBOOT_MASK);
 }
 
 /*************************************************************
@@ -114,7 +123,14 @@ u32 get_sysboot_value(void)
  *************************************************************/
 u32 get_mem_type(void)
 {
-	return GPMC_ONENAND;
+	u32 sb = get_sysboot_value();
+
+	if (sb == SYSBOOT_NAND)
+		return GPMC_NAND;
+	else if (sb == SYSBOOT_ONENAND)
+		return GPMC_ONENAND;
+	else
+		return -1;
 }
 
 /******************************************
@@ -165,6 +181,26 @@ u32 is_cpu_family(void)
 	return cpu_family;
 }
 
+/*
+ * Routine: get_prod_id
+ * Description: Get id info from chips
+ */
+
+#define PRODUCT_ID_SKUID	0x4830A20C
+#define CPU_35XX_PID_MASK	0x0000000F
+#define CPU_35XX_600MHZ_DEV	0x0
+#define CPU_35XX_720MHZ_DEV	0x8
+
+static u32 get_prod_id(void)
+{
+	u32 p;
+
+	/* get production ID */
+	p = __raw_readl(PRODUCT_ID_SKUID);
+
+	return (p & CPU_35XX_PID_MASK);
+}
+
 /*****************************************************************
  * sr32 - clear & set a value in a bit range for a 32 bit address
  *****************************************************************/
@@ -201,12 +237,19 @@ u32 wait_on_value(u32 read_bit_mask, u32 match_value, u32 read_addr, u32 bound)
  *************************************************************/
 u32 get_osc_clk_speed(void)
 {
-	u32 start, cstart, cend, cdiff, val;
+	u32 start, cstart, cend, cdiff, cdiv, val;
 
 	val = __raw_readl(PRM_CLKSRC_CTRL);
-	/* If SYS_CLK is being divided by 2, remove for now */
-	val = (val & (~BIT7)) | BIT6;
-	__raw_writel(val, PRM_CLKSRC_CTRL);
+
+	if (val & BIT7)
+		cdiv = 2;
+	else if (val & BIT6)
+		cdiv = 1;
+	else
+		/*
+		 * Should never reach here! assume divider as 1.
+		 */
+		cdiv = 1;
 
 	/* enable timer2 */
 	val = __raw_readl(CM_CLKSEL_WKUP) | BIT0;
@@ -231,6 +274,11 @@ u32 get_osc_clk_speed(void)
 	cend = __raw_readl(OMAP34XX_GPT1 + TCRR);	/* get end sys_clk count */
 	cdiff = cend - cstart;	/* get elapsed ticks */
 
+	if (cdiv == 2)
+	{
+		cdiff *= 2;
+	}
+
 	/* based on number of ticks assign speed */
 	if (cdiff > 19000)
 		return S38_4M;
@@ -668,12 +716,52 @@ void try_unlock_memory(void)
 	return;
 }
 
+
+/*
+ * Helper macros
+ */
+#define ONENAND_START_PAGE		0
+#define ONENAND_PAGES_PER_BLOCK		64
+
+#define onenand_readw(a)	(*(volatile unsigned short *)(a))
+#define onenand_writew(v, a)	((*(volatile unsigned short *)(a)) = (u16) (v))
+
+#define THIS_ONENAND(a)		(ONENAND_ADDR + (a))
+
+#define ONENAND_MANUF_ID()		\
+  (*(volatile unsigned short *)(THIS_ONENAND(ONENAND_REG_MANUFACTURER_ID)))
+
+#define ONENAND_DEVICE_ID()		\
+  (*(volatile unsigned short *)(THIS_ONENAND(ONENAND_REG_DEVICE_ID)))
+ 
+#define ONENAND_VERSION_ID()	\
+  (*(volatile unsigned short *)(THIS_ONENAND(ONENAND_REG_VERSION_ID)))
+ 
+#define ONENAND_TECHNOLOGY()	\
+  (*(volatile unsigned short *)(THIS_ONENAND(ONENAND_REG_TECHNOLOGY)))
+
+
+/*
+ * OneNAND Flash Manufacturer ID Codes
+ */
+#define ONENAND_MFR_SAMSUNG	0xec
+#define ONENAND_MFR_NUMONYX	0x20
+
+/*
+ * OneNAND Flash Devices ID Codes
+ */
+#define ONENAND_KFM1G16Q2A_DEV_ID	0x30
+#define ONENAND_KFN2G16Q2A_DEV_ID	0x40
+#define ONENAND_NAND01GR4E_DEV_ID	0x30
+#define ONENAND_NAND02GR4E_DEV_ID	0x40
+#define ONENAND_NAND04GR4E_DEV_ID	0x58
+
+
 /*********************************************************************
- * config_sdram_m65kx001am() - 1Gb, DDR x32 I/O, 4KB page
+ * config_sdram_mt29cxgxxmaxx() 
  *********************************************************************/
-void config_sdram_m65kx001am(void)
+void config_sdram(int actima, int actimb)
 {
-	/* M65KX001AM - 1Gb */
 	/* reset sdrc controller */
 	__raw_writel(SOFTRESET, SDRC_SYSCONFIG);
 	wait_on_value(BIT0, BIT0, SDRC_STATUS, 12000000);
@@ -681,43 +769,107 @@ void config_sdram_m65kx001am(void)
 
 	/* setup sdrc to ball mux */
 	__raw_writel(SDP_SDRC_SHARING, SDRC_SHARING);
-
-	/* __raw_writel(0x2, SDRC_CS_CFG); */
+	__raw_writel(0x2, SDRC_CS_CFG); /* 256 MB/bank */
 
 	/* CS0 SDRC Mode Register */
-	__raw_writel(MK65KX001AM_SDRC_MCDCFG, SDRC_MCFG_0);
+	__raw_writel((0x03588019|B_ALL), SDRC_MCFG_0);
+
+	/* CS1 SDRC Mode Register */
+	__raw_writel((0x03588019|B_ALL), SDRC_MCFG_1);
 
 	/* Set timings */
-	__raw_writel(NUMONYX_SDRC_ACTIM_CTRLA, SDRC_ACTIM_CTRLA_0);
-	__raw_writel(NUMONYX_SDRC_ACTIM_CTRLB, SDRC_ACTIM_CTRLB_0);
+	__raw_writel(actima, SDRC_ACTIM_CTRLA_0);
+	__raw_writel(actimb, SDRC_ACTIM_CTRLB_0);
+	__raw_writel(actima, SDRC_ACTIM_CTRLA_1);
+	__raw_writel(actimb, SDRC_ACTIM_CTRLB_1);
 
-	__raw_writel(SDP_SDRC_RFR_CTRL, SDRC_RFR_CTRL_0);
+	__raw_writel(SDP_SDRC_RFR_CTRL_200, SDRC_RFR_CTRL_0);
+	__raw_writel(SDP_SDRC_RFR_CTRL_200, SDRC_RFR_CTRL_1);
 
 	__raw_writel(SDP_SDRC_POWER_POP, SDRC_POWER);
 
 	/* init sequence for mDDR/mSDR using manual commands (DDR is different) */
 	__raw_writel(CMD_NOP, SDRC_MANUAL_0);
+	__raw_writel(CMD_NOP, SDRC_MANUAL_1);
 
 	delay(5000);
 
 	__raw_writel(CMD_PRECHARGE, SDRC_MANUAL_0);
+	__raw_writel(CMD_PRECHARGE, SDRC_MANUAL_1);
 
 	__raw_writel(CMD_AUTOREFRESH, SDRC_MANUAL_0);
+	__raw_writel(CMD_AUTOREFRESH, SDRC_MANUAL_1);
 
 	__raw_writel(CMD_AUTOREFRESH, SDRC_MANUAL_0);
+	__raw_writel(CMD_AUTOREFRESH, SDRC_MANUAL_1);
 
 	/* set mr0 */
 	__raw_writel(SDP_SDRC_MR_0_DDR, SDRC_MR_0);
+	__raw_writel(SDP_SDRC_MR_0_DDR, SDRC_MR_1);
 
 	/* set up dll */
 	__raw_writel(SDP_SDRC_DLLAB_CTRL, SDRC_DLLA_CTRL);
 	delay(0x2000);	/* give time to lock */
 }
 
+/*
+ * Configure Hynix NAND flash RAM memory module
+ */
+void config_sdram_hynix(void)
+{
+	config_sdram(HYNIX_V_ACTIMA_200, HYNIX_V_ACTIMB_200);
+}
+
+/*
+ * Configure Micron NAND flash RAM memory module
+ */
+void config_sdram_mt29cxgxxmaxx(void)
+{
+	config_sdram(MT29CXGXXMAXX_V_ACTIMA_200, MT29CXGXXMAXX_V_ACTIMB_200);
+}
+
+void config_nand_flash(void)
+{
+	/* global settings */
+	__raw_writel(0x10, GPMC_SYSCONFIG);	/* smart idle */
+	__raw_writel(0x0, GPMC_IRQENABLE);	/* isr's sources masked */
+	__raw_writel(0, GPMC_TIMEOUT_CONTROL);/* timeout disable */
+	__raw_writel(0x10, GPMC_CONFIG);	/* disable Write protect */
+
+	/* Set the GPMC Vals . For NAND boot on 3430SDP, NAND is mapped at CS0
+         *  , NOR at CS1 and MPDB at CS3. And oneNAND boot, we map oneNAND at CS0.
+	 *  We configure only GPMC CS0 with required values. Configiring other devices
+	 *  at other CS in done in u-boot anyway. So we don't have to bother doing it here.
+         */
+	__raw_writel(0 , GPMC_CONFIG7 + GPMC_CONFIG_CS0);
+	delay(1000);
+
+	__raw_writel(M_NAND_GPMC_CONFIG1, GPMC_CONFIG1 + GPMC_CONFIG_CS0);
+	__raw_writel(M_NAND_GPMC_CONFIG2, GPMC_CONFIG2 + GPMC_CONFIG_CS0);
+	__raw_writel(M_NAND_GPMC_CONFIG3, GPMC_CONFIG3 + GPMC_CONFIG_CS0);
+	__raw_writel(M_NAND_GPMC_CONFIG4, GPMC_CONFIG4 + GPMC_CONFIG_CS0);
+	__raw_writel(M_NAND_GPMC_CONFIG5, GPMC_CONFIG5 + GPMC_CONFIG_CS0);
+	__raw_writel(M_NAND_GPMC_CONFIG6, GPMC_CONFIG6 + GPMC_CONFIG_CS0);
+	__raw_writel(M_NAND_GPMC_CONFIG7, GPMC_CONFIG7 + GPMC_CONFIG_CS0);
+
+	__raw_writel(4144, GPMC_BASE + GPMC_ECC_CONFIG);
+	__raw_writel(0, GPMC_BASE + GPMC_ECC_CONTROL);
+
+	/* Enable the GPMC Mapping */
+	__raw_writel((((OMAP34XX_GPMC_CS0_SIZE & 0xF)<<8) |
+				((NAND_BASE_ADR>>24) & 0x3F) |
+				(1<<6) ),  (GPMC_CONFIG7 + GPMC_CONFIG_CS0));
+	delay(2000);
+}
+
+
+
+
+
 /*********************************************************************
  * config_sdram_m65kx002am() - 2 dice of 2Gb, DDR x32 I/O, 4KB page
  *********************************************************************/
-void config_sdram_m65kx002am(void)
+void config_sdram_m65kx002am(unsigned short MemID)
 {
 	/* M65KX002AM - 2 dice of 2Gb */
 	/* reset sdrc controller */
@@ -728,43 +880,71 @@ void config_sdram_m65kx002am(void)
 	/* setup sdrc to ball mux */
 	__raw_writel(SDP_SDRC_SHARING, SDRC_SHARING);
 
-	__raw_writel(0x2, SDRC_CS_CFG); /* 256 MB/bank */
 
-	/* CS0 SDRC Mode Register */
-	__raw_writel(MK65KX002AM_SDRC_MCDCFG, SDRC_MCFG_0);
+    switch(MemID){
+        case ONENAND_NAND02GR4E_DEV_ID:
+			/* CS0 SDRC Mode Register */
+            __raw_writel(MK65KX001AM_SDRC_MCDCFG, SDRC_MCFG_0);
+            break;
+        case ONENAND_NAND04GR4E_DEV_ID:
+            __raw_writel(0x2, SDRC_CS_CFG); /* 256 MB/bank */
+			/* CS0 SDRC Mode Register */
+            __raw_writel(MK65KX002AM_SDRC_MCDCFG, SDRC_MCFG_0);
+			/* CS1 SDRC Mode Register */
+            __raw_writel(MK65KX002AM_SDRC_MCDCFG, SDRC_MCFG_1);
+            break;
+        default:
+            hang();
+    }
 
-        /* CS1 SDRC Mode Register */
-        __raw_writel(MK65KX002AM_SDRC_MCDCFG, SDRC_MCFG_1);
 
 	/* Set timings */
-	__raw_writel(NUMONYX_SDRC_ACTIM_CTRLA, SDRC_ACTIM_CTRLA_0);
-	__raw_writel(NUMONYX_SDRC_ACTIM_CTRLB, SDRC_ACTIM_CTRLB_0);
-	__raw_writel(NUMONYX_SDRC_ACTIM_CTRLA, SDRC_ACTIM_CTRLA_1);
-	__raw_writel(NUMONYX_SDRC_ACTIM_CTRLB, SDRC_ACTIM_CTRLB_1);
+	if(is_cpu_family() == CPU_OMAP36XX){
+		__raw_writel(NUMONYX_SDRC_ACTIM_CTRLA_200, SDRC_ACTIM_CTRLA_0);
+        __raw_writel(NUMONYX_SDRC_ACTIM_CTRLB_200, SDRC_ACTIM_CTRLB_0);
+        __raw_writel(NUMONYX_SDRC_ACTIM_CTRLA_200, SDRC_ACTIM_CTRLA_1);
+        __raw_writel(NUMONYX_SDRC_ACTIM_CTRLB_200, SDRC_ACTIM_CTRLB_1);
+        __raw_writel(SDP_SDRC_RFR_CTRL_200, SDRC_RFR_CTRL_0);
+        if(MemID == ONENAND_NAND04GR4E_DEV_ID)
+            __raw_writel(SDP_SDRC_RFR_CTRL_200, SDRC_RFR_CTRL_1);
+    }
+    else{
+        __raw_writel(NUMONYX_SDRC_ACTIM_CTRLA_165, SDRC_ACTIM_CTRLA_0);
+        __raw_writel(NUMONYX_SDRC_ACTIM_CTRLB_165, SDRC_ACTIM_CTRLB_0);
+        __raw_writel(NUMONYX_SDRC_ACTIM_CTRLA_165, SDRC_ACTIM_CTRLA_1);
+        __raw_writel(NUMONYX_SDRC_ACTIM_CTRLB_165, SDRC_ACTIM_CTRLB_1);
+        __raw_writel(SDP_SDRC_RFR_CTRL_165, SDRC_RFR_CTRL_0);
+        if(MemID == ONENAND_NAND04GR4E_DEV_ID)
+            __raw_writel(SDP_SDRC_RFR_CTRL_165, SDRC_RFR_CTRL_1);
+
+    }
 
-	__raw_writel(SDP_SDRC_RFR_CTRL, SDRC_RFR_CTRL_0);
-	__raw_writel(SDP_SDRC_RFR_CTRL, SDRC_RFR_CTRL_1);
 
 	__raw_writel(SDP_SDRC_POWER_POP, SDRC_POWER);
 
 	/* init sequence for mDDR/mSDR using manual commands (DDR is different) */
 	__raw_writel(CMD_NOP, SDRC_MANUAL_0);
-	__raw_writel(CMD_NOP, SDRC_MANUAL_1);
+	if(MemID == ONENAND_NAND04GR4E_DEV_ID)
+        __raw_writel(CMD_NOP, SDRC_MANUAL_1);
 
 	delay(5000);
 
 	__raw_writel(CMD_PRECHARGE, SDRC_MANUAL_0);
-	__raw_writel(CMD_PRECHARGE, SDRC_MANUAL_1);
+	if(MemID == ONENAND_NAND04GR4E_DEV_ID)
+		__raw_writel(CMD_PRECHARGE, SDRC_MANUAL_1);
 
 	__raw_writel(CMD_AUTOREFRESH, SDRC_MANUAL_0);
-	__raw_writel(CMD_AUTOREFRESH, SDRC_MANUAL_1);
+	if(MemID == ONENAND_NAND04GR4E_DEV_ID)
+		__raw_writel(CMD_AUTOREFRESH, SDRC_MANUAL_1);
 
 	__raw_writel(CMD_AUTOREFRESH, SDRC_MANUAL_0);
-	__raw_writel(CMD_AUTOREFRESH, SDRC_MANUAL_1);
+	if(MemID == ONENAND_NAND04GR4E_DEV_ID)
+		__raw_writel(CMD_AUTOREFRESH, SDRC_MANUAL_1);
 
 	/* set mr0 */
 	__raw_writel(SDP_SDRC_MR_0_DDR, SDRC_MR_0);
-	__raw_writel(SDP_SDRC_MR_0_DDR, SDRC_MR_1);
+	if(MemID == ONENAND_NAND04GR4E_DEV_ID)
+		__raw_writel(SDP_SDRC_MR_0_DDR, SDRC_MR_1);
 
 	/* set up dll */
 	__raw_writel(SDP_SDRC_DLLAB_CTRL, SDRC_DLLA_CTRL);
@@ -811,23 +991,34 @@ void config_onenand_nand0xgr4wxa(void)
  * | M39B0RB0A0N1 | NAND02GR4E0A | M65KD001AM |
  *  -------------- -------------- ------------
  **********************************************************/
-void config_multichip_package()
+void config_multichip_package(void)
 {
 	config_onenand_nand0xgr4wxa();
 
-	switch (ONENAND_DEVICE_ID()) {
-	case ONENAND_NAND02GR4E_DEV_ID:
-		config_sdram_m65kx001am();
-		break;
-	case ONENAND_NAND04GR4E_DEV_ID:
-		config_sdram_m65kx002am();
-		break;
-	default:
-		board_hang();
-		break;
-	}
+	config_sdram_m65kx002am(ONENAND_DEVICE_ID());
+
+}
+
+/*********************************************************************
+ * config_gpmc_init() 
+ *********************************************************************/
+void config_gpmc_init(void)
+{
+	u32 config = 0;
+	/* global settings */
+	__raw_writel(0x0, GPMC_IRQENABLE);	/* isr's sources masked */
+	__raw_writel(0, GPMC_TIMEOUT_CONTROL);/* timeout disable */
+
+	/* Set WAIT polarity actuve low*/
+	config = __raw_readl(GPMC_CONFIG);
+	config &= (~0xf00);
+	__raw_writel(config, GPMC_CONFIG);
+
+	__raw_writel(0 , GPMC_CONFIG7 + GPMC_CONFIG_CS0);
+	delay(1000);
 }
 
+
 /**********************************************************
  * Routine: s_init
  * Description: Does early system init of muxing and clocks.
@@ -835,34 +1026,208 @@ void config_multichip_package()
  **********************************************************/
 void s_init(void)
 {
-	watchdog_init();
+	u32 mem_type;
 
+	watchdog_init();
 	try_unlock_memory();
 	set_muxconf_regs();
 	delay(100);
 	prcm_init();
 	per_clocks_enable();
-	config_multichip_package();
+	config_gpmc_init();
+
+    // Turn On USER1 led
+	omap_request_gpio(GPIO_LED_USER1);
+	omap_set_gpio_direction(GPIO_LED_USER1, 0);
+	omap_set_gpio_dataout(GPIO_LED_USER1, 1);
+
+	mem_type = get_mem_type();
+
+	if(mem_type == GPMC_ONENAND)
+		config_multichip_package();
+	else if(mem_type == GPMC_NAND) {
+		config_nand_flash();
+		//config_sdram_mt29cxgxxmaxx();
+		//config_nand_mt29cxgxxmaxx();
+	}
+}
+
+void setup_net_chip (u32 processor)
+{
+    int i;
+	unsigned short val;
+	unsigned int lval;
+
+	/* Configure GPMC registers */
+	if(processor == CPU_OMAP36XX){
+		__raw_writel(NET_GPMC_CONFIG1, GPMC_CONFIG1 + GPMC_CONFIG_CS5);
+		__raw_writel(NET_GPMC_CONFIG2, GPMC_CONFIG2 + GPMC_CONFIG_CS5);
+		__raw_writel(NET_GPMC_CONFIG3, GPMC_CONFIG3 + GPMC_CONFIG_CS5);
+		__raw_writel(NET_GPMC_CONFIG4, GPMC_CONFIG4 + GPMC_CONFIG_CS5);
+		__raw_writel(NET_GPMC_CONFIG5, GPMC_CONFIG5 + GPMC_CONFIG_CS5);
+		__raw_writel(NET_GPMC_CONFIG6, GPMC_CONFIG6 + GPMC_CONFIG_CS5);
+		__raw_writel(NET_GPMC_CONFIG7, GPMC_CONFIG7 + GPMC_CONFIG_CS5);
+	}
+	else{
+		__raw_writel(NET_LAN9221_GPMC_CONFIG1, GPMC_CONFIG1 + GPMC_CONFIG_CS5);
+		__raw_writel(NET_LAN9221_GPMC_CONFIG2, GPMC_CONFIG2 + GPMC_CONFIG_CS5);
+		__raw_writel(NET_LAN9221_GPMC_CONFIG3, GPMC_CONFIG3 + GPMC_CONFIG_CS5);
+		__raw_writel(NET_LAN9221_GPMC_CONFIG4, GPMC_CONFIG4 + GPMC_CONFIG_CS5);
+		__raw_writel(NET_LAN9221_GPMC_CONFIG5, GPMC_CONFIG5 + GPMC_CONFIG_CS5);
+		__raw_writel(NET_LAN9221_GPMC_CONFIG6, GPMC_CONFIG6 + GPMC_CONFIG_CS5);
+		__raw_writel(NET_LAN9221_GPMC_CONFIG7, GPMC_CONFIG7 + GPMC_CONFIG_CS5);
+#ifdef __notdef
+        // IGEP Module with DUAL Ethernet
+		__raw_writel(NET_LAN9221_GPMC_CONFIG1, GPMC_CONFIG1 + GPMC_CONFIG_CS4);
+		__raw_writel(NET_LAN9221_GPMC_CONFIG2, GPMC_CONFIG2 + GPMC_CONFIG_CS4);
+		__raw_writel(NET_LAN9221_GPMC_CONFIG3, GPMC_CONFIG3 + GPMC_CONFIG_CS4);
+		__raw_writel(NET_LAN9221_GPMC_CONFIG4, GPMC_CONFIG4 + GPMC_CONFIG_CS4);
+		__raw_writel(NET_LAN9221_GPMC_CONFIG5, GPMC_CONFIG5 + GPMC_CONFIG_CS4);
+		__raw_writel(NET_LAN9221_GPMC_CONFIG6, GPMC_CONFIG6 + GPMC_CONFIG_CS4);
+		__raw_writel(NET_LAN9221_GPMC_CONFIG7, GPMC_CONFIG7 + GPMC_CONFIG_CS4);
+#endif
+    }
+
+	/* Enable off mode for NWE in PADCONF_GPMC_NWE register */
+	val = __raw_readw(OMAP34XX_CTRL_BASE+CONTROL_PADCONF_GPMC_nWE)|0x0E00;
+	__raw_writew(val, OMAP34XX_CTRL_BASE+CONTROL_PADCONF_GPMC_nWE);
+	/* Enable off mode for NOE in PADCONF_GPMC_NADV_ALE register */
+	val = __raw_readw(OMAP34XX_CTRL_BASE+CONTROL_PADCONF_GPMC_nOE)|0x0E00;
+	__raw_writew(val, OMAP34XX_CTRL_BASE+CONTROL_PADCONF_GPMC_nOE);
+	/* Enable off mode for ALE in PADCONF_GPMC_NADV_ALE register */
+	val = __raw_readw(OMAP34XX_CTRL_BASE+CONTROL_PADCONF_GPMC_nADV_ALE)|0x0E00;
+	__raw_writew(val, OMAP34XX_CTRL_BASE+CONTROL_PADCONF_GPMC_nADV_ALE);
+
+	/* Make GPIO 64 as output pin */
+	lval = __raw_readl(OMAP34XX_GPIO3_BASE+OMAP24XX_GPIO_OE) & ~(0x1 << 0);
+	__raw_writel(lval, OMAP34XX_GPIO3_BASE+OMAP24XX_GPIO_OE);
+
+	/* Now send a pulse on the GPIO pin */
+	__raw_writel((0x1 << 0), OMAP34XX_GPIO3_BASE+OMAP24XX_GPIO_SETDATAOUT);
+	udelay(1);
+	__raw_writel((0x1 << 0), OMAP34XX_GPIO3_BASE+OMAP24XX_GPIO_CLEARDATAOUT);
+	udelay(1);
+	__raw_writel((0x1 << 0), OMAP34XX_GPIO3_BASE+OMAP24XX_GPIO_SETDATAOUT);
+
 }
 
+
+#define NAND_MICRON_ID		0x2c  /* Micron */
+
 /*****************************************
  * Routine: board_init
  * Description: Early hardware init.
  *****************************************/
 int board_init(void)
 {
+	unsigned char data;
+	u32 mid;
+
+	nand_mfr = 0;
+	mid = 0;
+
+	// Turn ON USER0 led
+	omap_request_gpio(GPIO_LED_USER0);
+	omap_set_gpio_direction(GPIO_LED_USER0, 0);
+	omap_set_gpio_dataout(GPIO_LED_USER0, 1);
+
+	if(is_cpu_family() == CPU_OMAP36XX){
+        // Init TPS65950 - Voltage Selection (1.35V)
+        // Calculation using this formula:
+        // VSel = Vout - 600 / 12.5 ( all values in mili-Volts)
+        // VSel = 1350 - 600 / 12.5 = 60 -> Hex = 0x3C
+        data = 0x3C;
+        // 1.4 V
+        // --> data = 0x40;
+        i2c_write(0x4B, 0xb9, 1, &data, 1);
+    }
+    else {
+        if (get_prod_id() == CPU_35XX_720MHZ_DEV){
+            // Init TPS65950 - Voltage Selection (1.35V)
+            data = 0x3C;
+            i2c_write(0x4B, 0xb9, 1, &data, 1);
+        }
+    }
+    // Setup gpmc <-> Ethernet
+    setup_net_chip(is_cpu_family());
+    if(get_mem_type() == GPMC_NAND){
+		read_nand_manufacturer_id(&nand_mfr, &mid);
+		if(nand_mfr == NAND_MICRON_ID){
+			config_sdram_mt29cxgxxmaxx();
+		} else {
+			config_sdram_hynix();
+		}
+		//nand_command(NAND_CMD_RESET);
+	}
+
 	return 0;
 }
 
+
+#define OMAP3730_MAX_RELEASES   4
+
+static char *rev_s[OMAP3730_MAX_RELEASES] = {
+  "1.0", /* 0 */
+  "1.1", /* 1 */
+  "1.2", /* 2 */
+  "Unknown",
+};
+
 /*******************************************************
  * Routine: misc_init_r
  * Description: Init ethernet (done here so udelay works)
  ********************************************************/
 int misc_init_r(void)
 {
-	omap_request_gpio(27);
-	omap_set_gpio_direction(27, 0);
-	omap_set_gpio_dataout(27, 1);
+	u32 cpu_status;
+    u16 cpu_id;
+    char prod_id[16];
+    u32 cpu_release;
+    u8 rev;
+    u32 mem_type;
+
+	udelay(50000);
+	// Turn Off USER0 led
+	omap_request_gpio(GPIO_LED_USER0);
+	omap_set_gpio_direction(GPIO_LED_USER0, 0);
+	omap_set_gpio_dataout(GPIO_LED_USER0, 0);
+    // Turn Off USER1 led
+	omap_request_gpio(GPIO_LED_USER1);
+	omap_set_gpio_direction(GPIO_LED_USER1, 0);
+	omap_set_gpio_dataout(GPIO_LED_USER1, 0);
+    // Turn On USER2 led
+	omap_request_gpio(GPIO_LED_USER2);
+	omap_set_gpio_direction(GPIO_LED_USER2, 0);
+	omap_set_gpio_dataout(GPIO_LED_USER2, 1);
+
+		// Print Configuration Setup
+	if(is_cpu_family() == CPU_OMAP36XX){
+		cpu_release = __raw_readl(OMAP34XX_CONTROL_ID);
+		rev = (cpu_release >> 28) & 0xff;
+
+		printf("CPU Release: 0x%x - 0x%x\n", cpu_release, rev);
+
+		if(rev >= OMAP3730_MAX_RELEASES) rev = OMAP3730_MAX_RELEASES -1;
+		cpu_id = __raw_readl(OMAP3XXX_STATUS_ID);
+
+		printf("XLoader: CPU status = 0x%x\n", cpu_id);
+
+		switch(cpu_id){
+			case 0x0c00:
+			case 0x0e00: printf("XLoader: Processor DM3730 - ES%s\n", rev_s[rev]); break;
+			case 0x5c00:
+			case 0x5e00: printf("XLoader: Processor AM3703 - ES%s\n", rev_s[rev]); break;
+		}
+	}
+	else 
+		printf("XLoader: Processor OMAP3530\n");
+
+	// Show Memory Manufacturer
+	mem_type = get_mem_type();
+	if(mem_type == GPMC_ONENAND)
+		printf("XLoader: Memory Manufacturer: %s\n", "Numonyx");
+	else
+		printf("XLoader: Memory Manufacturer: %s (%x)\n", (nand_mfr == NAND_MICRON_ID) ? "Micron" : "Hynix", nand_mfr);
 
 	return 0;
 }
@@ -1122,6 +1487,354 @@ void per_clocks_enable(void)
 	MUX_VAL(CP(sdrc_cke0),      (IDIS | PTU | EN  | M0)) /*sdrc_cke0 */\
 	MUX_VAL(CP(sdrc_cke1),      (IDIS | PTD | DIS | M7)) /*sdrc_cke1 not used*/
 
+
+
+
+
+#define MUX_IGEP0020() \
+ MUX_VAL(CP(SDRC_D0),		(IEN  | PTD | DIS | M0)) /* SDRC_D0  */\
+ MUX_VAL(CP(SDRC_D1),		(IEN  | PTD | DIS | M0)) /* SDRC_D1  */\
+ MUX_VAL(CP(SDRC_D2),		(IEN  | PTD | DIS | M0)) /* SDRC_D2  */\
+ MUX_VAL(CP(SDRC_D3),		(IEN  | PTD | DIS | M0)) /* SDRC_D3  */\
+ MUX_VAL(CP(SDRC_D4),		(IEN  | PTD | DIS | M0)) /* SDRC_D4  */\
+ MUX_VAL(CP(SDRC_D5),		(IEN  | PTD | DIS | M0)) /* SDRC_D5  */\
+ MUX_VAL(CP(SDRC_D6),		(IEN  | PTD | DIS | M0)) /* SDRC_D6  */\
+ MUX_VAL(CP(SDRC_D7),		(IEN  | PTD | DIS | M0)) /* SDRC_D7  */\
+ MUX_VAL(CP(SDRC_D8),		(IEN  | PTD | DIS | M0)) /* SDRC_D8  */\
+ MUX_VAL(CP(SDRC_D9),		(IEN  | PTD | DIS | M0)) /* SDRC_D9  */\
+ MUX_VAL(CP(SDRC_D10),		(IEN  | PTD | DIS | M0)) /* SDRC_D10 */\
+ MUX_VAL(CP(SDRC_D11),		(IEN  | PTD | DIS | M0)) /* SDRC_D11 */\
+ MUX_VAL(CP(SDRC_D12),		(IEN  | PTD | DIS | M0)) /* SDRC_D12 */\
+ MUX_VAL(CP(SDRC_D13),		(IEN  | PTD | DIS | M0)) /* SDRC_D13 */\
+ MUX_VAL(CP(SDRC_D14),		(IEN  | PTD | DIS | M0)) /* SDRC_D14 */\
+ MUX_VAL(CP(SDRC_D15),		(IEN  | PTD | DIS | M0)) /* SDRC_D15 */\
+ MUX_VAL(CP(SDRC_D16),		(IEN  | PTD | DIS | M0)) /* SDRC_D16 */\
+ MUX_VAL(CP(SDRC_D17),		(IEN  | PTD | DIS | M0)) /* SDRC_D17 */\
+ MUX_VAL(CP(SDRC_D18),		(IEN  | PTD | DIS | M0)) /* SDRC_D18 */\
+ MUX_VAL(CP(SDRC_D19),		(IEN  | PTD | DIS | M0)) /* SDRC_D19 */\
+ MUX_VAL(CP(SDRC_D20),		(IEN  | PTD | DIS | M0)) /* SDRC_D20 */\
+ MUX_VAL(CP(SDRC_D21),		(IEN  | PTD | DIS | M0)) /* SDRC_D21 */\
+ MUX_VAL(CP(SDRC_D22),		(IEN  | PTD | DIS | M0)) /* SDRC_D22 */\
+ MUX_VAL(CP(SDRC_D23),		(IEN  | PTD | DIS | M0)) /* SDRC_D23 */\
+ MUX_VAL(CP(SDRC_D24),		(IEN  | PTD | DIS | M0)) /* SDRC_D24 */\
+ MUX_VAL(CP(SDRC_D25),		(IEN  | PTD | DIS | M0)) /* SDRC_D25 */\
+ MUX_VAL(CP(SDRC_D26),		(IEN  | PTD | DIS | M0)) /* SDRC_D26 */\
+ MUX_VAL(CP(SDRC_D27),		(IEN  | PTD | DIS | M0)) /* SDRC_D27 */\
+ MUX_VAL(CP(SDRC_D28),		(IEN  | PTD | DIS | M0)) /* SDRC_D28 */\
+ MUX_VAL(CP(SDRC_D29),		(IEN  | PTD | DIS | M0)) /* SDRC_D29 */\
+ MUX_VAL(CP(SDRC_D30),		(IEN  | PTD | DIS | M0)) /* SDRC_D30 */\
+ MUX_VAL(CP(SDRC_D31),		(IEN  | PTD | DIS | M0)) /* SDRC_D31 */\
+ MUX_VAL(CP(SDRC_CLK),		(IEN  | PTD | DIS | M0)) /* SDRC_CLK */\
+ MUX_VAL(CP(SDRC_DQS0),		(IEN  | PTD | DIS | M0)) /* SDRC_DQS0*/\
+ MUX_VAL(CP(SDRC_DQS1),		(IEN  | PTD | DIS | M0)) /* SDRC_DQS1*/\
+ MUX_VAL(CP(SDRC_DQS2),		(IEN  | PTD | DIS | M0)) /* SDRC_DQS2*/\
+ MUX_VAL(CP(SDRC_DQS3),		(IEN  | PTD | DIS | M0)) /* SDRC_DQS3*/\
+ /* GPMC - General-Purpose Memory Controller */\
+ MUX_VAL(CP(GPMC_A1),		(IDIS | PTU | EN  | M0)) /* GPMC_A1       */\
+ MUX_VAL(CP(GPMC_A2),		(IDIS | PTU | EN  | M0)) /* GPMC_A2       */\
+ MUX_VAL(CP(GPMC_A3),		(IDIS | PTU | EN  | M0)) /* GPMC_A3       */\
+ MUX_VAL(CP(GPMC_A4),		(IDIS | PTU | EN  | M0)) /* GPMC_A4       */\
+ MUX_VAL(CP(GPMC_A5),		(IDIS | PTU | EN  | M0)) /* GPMC_A5       */\
+ MUX_VAL(CP(GPMC_A6),		(IDIS | PTU | EN  | M0)) /* GPMC_A6       */\
+ MUX_VAL(CP(GPMC_A7),		(IDIS | PTU | EN  | M0)) /* GPMC_A7       */\
+ MUX_VAL(CP(GPMC_A8),		(IDIS | PTU | EN  | M0)) /* GPMC_A8       */\
+ MUX_VAL(CP(GPMC_A9),		(IDIS | PTU | EN  | M0)) /* GPMC_A9       */\
+ MUX_VAL(CP(GPMC_A10),		(IDIS | PTU | EN  | M0)) /* GPMC_A10      */\
+ MUX_VAL(CP(GPMC_D0),		(IEN  | PTU | EN  | M0)) /* GPMC_D0       */\
+ MUX_VAL(CP(GPMC_D1),		(IEN  | PTU | EN  | M0)) /* GPMC_D1       */\
+ MUX_VAL(CP(GPMC_D2),		(IEN  | PTU | EN  | M0)) /* GPMC_D2       */\
+ MUX_VAL(CP(GPMC_D3),		(IEN  | PTU | EN  | M0)) /* GPMC_D3       */\
+ MUX_VAL(CP(GPMC_D4),		(IEN  | PTU | EN  | M0)) /* GPMC_D4       */\
+ MUX_VAL(CP(GPMC_D5),		(IEN  | PTU | EN  | M0)) /* GPMC_D5       */\
+ MUX_VAL(CP(GPMC_D6),		(IEN  | PTU | EN  | M0)) /* GPMC_D6       */\
+ MUX_VAL(CP(GPMC_D7),		(IEN  | PTU | EN  | M0)) /* GPMC_D7       */\
+ MUX_VAL(CP(GPMC_D8),		(IEN  | PTU | EN  | M0)) /* GPMC_D8       */\
+ MUX_VAL(CP(GPMC_D9),		(IEN  | PTU | EN  | M0)) /* GPMC_D9       */\
+ MUX_VAL(CP(GPMC_D10),		(IEN  | PTU | EN  | M0)) /* GPMC_D10      */\
+ MUX_VAL(CP(GPMC_D11),		(IEN  | PTU | EN  | M0)) /* GPMC_D11      */\
+ MUX_VAL(CP(GPMC_D12),		(IEN  | PTU | EN  | M0)) /* GPMC_D12      */\
+ MUX_VAL(CP(GPMC_D13),		(IEN  | PTU | EN  | M0)) /* GPMC_D13      */\
+ MUX_VAL(CP(GPMC_D14),		(IEN  | PTU | EN  | M0)) /* GPMC_D14      */\
+ MUX_VAL(CP(GPMC_D15),		(IEN  | PTU | EN  | M0)) /* GPMC_D15      */\
+ MUX_VAL(CP(GPMC_nCS0),		(IDIS | PTU | EN  | M0)) /* GPMC_nCS0     */\
+ MUX_VAL(CP(GPMC_nCS1),		(IDIS | PTU | EN  | M0)) /* GPMC_nCS1     */\
+ MUX_VAL(CP(GPMC_nCS2),		(IDIS | PTU | EN  | M0)) /* GPMC_nCS2     */\
+ MUX_VAL(CP(GPMC_nCS3),		(IDIS | PTU | EN  | M0)) /* GPMC_nCS3     */\
+ MUX_VAL(CP(GPMC_nCS4),		(IDIS | PTU | EN  | M0)) /* GPMC_nCS4     */\
+ MUX_VAL(CP(GPMC_nCS5),		(IDIS | PTU | EN  | M0)) /* GPMC_nCS5     */\
+ MUX_VAL(CP(GPMC_nCS6),		(IDIS | PTU | EN  | M0)) /* GPMC_nCS6     */\
+ MUX_VAL(CP(GPMC_nOE),		(IDIS | PTD | DIS | M0)) /* GPMC_nOE      */\
+ MUX_VAL(CP(GPMC_nWE),		(IDIS | PTD | DIS | M0)) /* GPMC_nWE      */\
+ \
+ MUX_VAL(CP(GPMC_WAIT2),	(IEN  | PTU | EN  | M4)) /* GPIO_64 -ETH_NRESET */\
+ \
+ MUX_VAL(CP(GPMC_nCS7),		(IEN  | PTU | EN  | M1)) /* SYS_nDMA_REQ3 */\
+ MUX_VAL(CP(GPMC_CLK),		(IDIS | PTD | DIS | M0)) /* GPMC_CLK      */\
+ MUX_VAL(CP(GPMC_nBE1),		(IEN  | PTD | DIS | M0)) /* GPMC_nBE1     */\
+ MUX_VAL(CP(GPMC_nADV_ALE),	(IDIS | PTD | DIS | M0)) /* GPMC_nADV_ALE */\
+ MUX_VAL(CP(GPMC_nBE0_CLE),	(IDIS | PTD | DIS | M0)) /* GPMC_nBE0_CLE */\
+ MUX_VAL(CP(GPMC_nWP),		(IEN  | PTD | DIS | M0)) /* GPMC_nWP      */\
+ MUX_VAL(CP(GPMC_WAIT0),	(IEN  | PTU | EN  | M0)) /* GPMC_WAIT0    */\
+ MUX_VAL(CP(GPMC_WAIT1),	(IEN  | PTU | EN  | M0)) /* GPMC_WAIT1    */\
+ MUX_VAL(CP(GPMC_WAIT3),	(IEN  | PTU | EN  | M0)) /* GPMC_WAIT3    */\
+ /* DSS */\
+ MUX_VAL(CP(DSS_PCLK),		(IDIS | PTD | DIS | M0)) /* DSS_PCLK   */\
+ MUX_VAL(CP(DSS_HSYNC),		(IDIS | PTD | DIS | M0)) /* DSS_HSYNC  */\
+ MUX_VAL(CP(DSS_VSYNC),		(IDIS | PTD | DIS | M0)) /* DSS_VSYNC  */\
+ MUX_VAL(CP(DSS_ACBIAS),	(IDIS | PTD | DIS | M0)) /* DSS_ACBIAS */\
+ MUX_VAL(CP(DSS_DATA0),		(IDIS | PTD | DIS | M0)) /* DSS_DATA0  */\
+ MUX_VAL(CP(DSS_DATA1),		(IDIS | PTD | DIS | M0)) /* DSS_DATA1  */\
+ MUX_VAL(CP(DSS_DATA2),		(IDIS | PTD | DIS | M0)) /* DSS_DATA2  */\
+ MUX_VAL(CP(DSS_DATA3),		(IDIS | PTD | DIS | M0)) /* DSS_DATA3  */\
+ MUX_VAL(CP(DSS_DATA4),		(IDIS | PTD | DIS | M0)) /* DSS_DATA4  */\
+ MUX_VAL(CP(DSS_DATA5),		(IDIS | PTD | DIS | M0)) /* DSS_DATA5  */\
+ MUX_VAL(CP(DSS_DATA6),		(IDIS | PTD | DIS | M0)) /* DSS_DATA6  */\
+ MUX_VAL(CP(DSS_DATA7),		(IDIS | PTD | DIS | M0)) /* DSS_DATA7  */\
+ MUX_VAL(CP(DSS_DATA8),		(IDIS | PTD | DIS | M0)) /* DSS_DATA8  */\
+ MUX_VAL(CP(DSS_DATA9),		(IDIS | PTD | DIS | M0)) /* DSS_DATA9  */\
+ MUX_VAL(CP(DSS_DATA10),	(IDIS | PTD | DIS | M0)) /* DSS_DATA10 */\
+ MUX_VAL(CP(DSS_DATA11),	(IDIS | PTD | DIS | M0)) /* DSS_DATA11 */\
+ MUX_VAL(CP(DSS_DATA12),	(IDIS | PTD | DIS | M0)) /* DSS_DATA12 */\
+ MUX_VAL(CP(DSS_DATA13),	(IDIS | PTD | DIS | M0)) /* DSS_DATA13 */\
+ MUX_VAL(CP(DSS_DATA14),	(IDIS | PTD | DIS | M0)) /* DSS_DATA14 */\
+ MUX_VAL(CP(DSS_DATA15),	(IDIS | PTD | DIS | M0)) /* DSS_DATA15 */\
+ MUX_VAL(CP(DSS_DATA16),	(IDIS | PTD | DIS | M0)) /* DSS_DATA16 */\
+ MUX_VAL(CP(DSS_DATA17),	(IDIS | PTD | DIS | M0)) /* DSS_DATA17 */\
+ MUX_VAL(CP(DSS_DATA18),	(IDIS | PTD | DIS | M0)) /* DSS_DATA18 */\
+ MUX_VAL(CP(DSS_DATA19),	(IDIS | PTD | DIS | M0)) /* DSS_DATA19 */\
+ MUX_VAL(CP(DSS_DATA20),	(IDIS | PTD | DIS | M0)) /* DSS_DATA20 */\
+ MUX_VAL(CP(DSS_DATA21),	(IDIS | PTD | DIS | M0)) /* DSS_DATA21 */\
+ MUX_VAL(CP(DSS_DATA22),	(IDIS | PTD | DIS | M0)) /* DSS_DATA22 */\
+ MUX_VAL(CP(DSS_DATA23),	(IDIS | PTD | DIS | M0)) /* DSS_DATA23 */\
+ /* Audio Interface */\
+ MUX_VAL(CP(McBSP2_FSX),	(IEN  | PTD | DIS | M0)) /* McBSP2_FSX  */\
+ MUX_VAL(CP(McBSP2_CLKX),	(IEN  | PTD | DIS | M0)) /* McBSP2_CLKX */\
+ MUX_VAL(CP(McBSP2_DR),		(IEN  | PTD | DIS | M0)) /* McBSP2_DR   */\
+ MUX_VAL(CP(McBSP2_DX),		(IDIS | PTD | DIS | M0)) /* McBSP2_DX   */\
+ /* Expansion card 1 */\
+ MUX_VAL(CP(MMC1_CLK),		(IDIS | PTU | EN  | M0)) /* MMC1_CLK  */\
+ MUX_VAL(CP(MMC1_CMD),		(IEN  | PTU | EN  | M0)) /* MMC1_CMD  */\
+ MUX_VAL(CP(MMC1_DAT0),		(IEN  | PTU | EN  | M0)) /* MMC1_DAT0 */\
+ MUX_VAL(CP(MMC1_DAT1),		(IEN  | PTU | EN  | M0)) /* MMC1_DAT1 */\
+ MUX_VAL(CP(MMC1_DAT2),		(IEN  | PTU | EN  | M0)) /* MMC1_DAT2 */\
+ MUX_VAL(CP(MMC1_DAT3),		(IEN  | PTU | EN  | M0)) /* MMC1_DAT3 */\
+ \
+ MUX_VAL(CP(MMC1_DAT4),		(IEN  | PTU | EN  | M0)) /* MMC1_DAT4 */\
+ MUX_VAL(CP(MMC1_DAT5),		(IEN  | PTU | EN  | M0)) /* MMC1_DAT5 */\
+ MUX_VAL(CP(MMC1_DAT6),		(IEN  | PTU | EN  | M0)) /* MMC1_DAT6 */\
+ MUX_VAL(CP(MMC1_DAT7),		(IEN  | PTU | EN  | M0)) /* MMC1_DAT7 */\
+ /* SDIO Interface to WIFI Module (EXPANSION CONNECTOR) */\
+ MUX_VAL(CP(MMC2_CLK),		(IEN  | PTU | EN  | M0)) /* MMC2_CLK  */\
+ MUX_VAL(CP(MMC2_CMD),		(IEN  | PTU | EN  | M0)) /* MMC2_CMD  */\
+ MUX_VAL(CP(MMC2_DAT0),		(IEN  | PTU | EN  | M0)) /* MMC2_DAT0 */\
+ MUX_VAL(CP(MMC2_DAT1),		(IEN  | PTU | EN  | M0)) /* MMC2_DAT1 */\
+ MUX_VAL(CP(MMC2_DAT2),		(IEN  | PTU | EN  | M0)) /* MMC2_DAT2 */\
+ MUX_VAL(CP(MMC2_DAT3),		(IEN  | PTU | EN  | M0)) /* MMC2_DAT3 */\
+ \
+ /* GSPI Interface to WIFI Module */ \
+/* MUX_VAL(CP(MMC2_CLK),		(IEN  | PTD | DIS | M1)) McSPI3_CLK  */\
+/* MUX_VAL(CP(MMC2_CMD),		(IEN  | PTD | DIS | M1)) McSPI3_SIMO */\
+/* MUX_VAL(CP(MMC2_DAT0),		(IEN  | PTD | DIS | M1)) McSPI3_SOMI */\
+/* MUX_VAL(CP(MMC2_DAT1),		(IEN  | PTD | DIS | M4)) GPIO_133    */\
+/* MUX_VAL(CP(MMC2_DAT2),		(IEN  | PTD | DIS | M4)) GPIO_134    */\
+/* MUX_VAL(CP(MMC2_DAT3),		(IEN  | PTD | DIS | M4)) GPIO_135 (GPIO-Based CS) */\
+ \
+ MUX_VAL(CP(CAM_HS),		(IDIS | PTD | DIS | M4)) /* GPIO_94 - PDN (Rev. B) */\
+ MUX_VAL(CP(CAM_VS),		(IDIS | PTD | DIS | M4)) /* GPIO_95 - RESET_N_W (Rev. B) */\
+ \
+ MUX_VAL(CP(MMC2_DAT4),		(IDIS | PTD | DIS | M4)) /* GPIO_136 */\
+ MUX_VAL(CP(MMC2_DAT5),		(IDIS | PTD | DIS | M4)) /* GPIO_137 - RESET_N_B */\
+ MUX_VAL(CP(MMC2_DAT6),		(IDIS | PTD | DIS | M4)) /* GPIO_138 - PDN (Rev. C)  */\
+ MUX_VAL(CP(MMC2_DAT7),		(IDIS | PTD | DIS | M4)) /* GPIO_139 - RESET_N_W (Rev. C) */\
+ /* Bluetooth (EXPANSION CONNECTOR) */\
+ MUX_VAL(CP(McBSP3_DX),		(IDIS | PTD | DIS | M0)) /* McBSP3_DX */\
+ MUX_VAL(CP(McBSP3_DR),		(IEN  | PTD | DIS | M0)) /* McBSP3_DR */\
+ MUX_VAL(CP(McBSP3_CLKX),	(IEN  | PTD | DIS | M0)) /* McBSP3_CLKX  */\
+ MUX_VAL(CP(McBSP3_FSX),	(IEN  | PTD | DIS | M0)) /* McBSP3_FSX   */\
+ MUX_VAL(CP(UART2_CTS),		(IEN  | PTU | EN  | M0)) /* UART2_CTS */\
+ MUX_VAL(CP(UART2_RTS),		(IDIS | PTD | DIS | M0)) /* UART2_RTS */\
+ MUX_VAL(CP(UART2_TX),		(IDIS | PTD | DIS | M0)) /* UART2_TX  */\
+ MUX_VAL(CP(UART2_RX),		(IEN  | PTD | DIS | M0)) /* UART2_RX  */\
+ /* 485 Interface */\
+ MUX_VAL(CP(UART1_TX),		(IDIS | PTD | DIS | M0)) /* UART1_TX  */\
+ MUX_VAL(CP(UART1_RTS),		(IDIS | PTD | DIS | M0)) /* UART1_RTS */\
+ MUX_VAL(CP(UART1_CTS),		(IEN  | PTU | DIS | M0)) /* UART1_CTS */\
+ MUX_VAL(CP(UART1_RX),		(IEN  | PTD | DIS | M0)) /* UART1_RX  */\
+ MUX_VAL(CP(McBSP4_CLKX),	(IDIS | PTD | DIS | M4)) /* GPIO_152  */\
+ /* Serial Interface */\
+ MUX_VAL(CP(UART3_CTS_RCTX),	(IEN  | PTD | EN  | M0)) /* UART3_CTS_RCTX*/\
+ MUX_VAL(CP(UART3_RTS_SD),	(IDIS | PTD | DIS | M0)) /* UART3_RTS_SD */\
+ MUX_VAL(CP(UART3_RX_IRRX),	(IEN  | PTD | DIS | M0)) /* UART3_RX_IRRX*/\
+ MUX_VAL(CP(UART3_TX_IRTX),	(IDIS | PTD | DIS | M0)) /* UART3_TX_IRTX*/\
+ MUX_VAL(CP(HSUSB0_CLK),	(IEN  | PTD | DIS | M0)) /* HSUSB0_CLK*/\
+ MUX_VAL(CP(HSUSB0_STP),	(IDIS | PTU | EN  | M0)) /* HSUSB0_STP*/\
+ MUX_VAL(CP(HSUSB0_DIR),	(IEN  | PTD | DIS | M0)) /* HSUSB0_DIR*/\
+ MUX_VAL(CP(HSUSB0_NXT),	(IEN  | PTD | DIS | M0)) /* HSUSB0_NXT*/\
+ MUX_VAL(CP(HSUSB0_DATA0),	(IEN  | PTD | DIS | M0)) /* HSUSB0_DATA0*/\
+ MUX_VAL(CP(HSUSB0_DATA1),	(IEN  | PTD | DIS | M0)) /* HSUSB0_DATA1*/\
+ MUX_VAL(CP(HSUSB0_DATA2),	(IEN  | PTD | DIS | M0)) /* HSUSB0_DATA2*/\
+ MUX_VAL(CP(HSUSB0_DATA3),	(IEN  | PTD | DIS | M0)) /* HSUSB0_DATA3*/\
+ MUX_VAL(CP(HSUSB0_DATA4),	(IEN  | PTD | DIS | M0)) /* HSUSB0_DATA4*/\
+ MUX_VAL(CP(HSUSB0_DATA5),	(IEN  | PTD | DIS | M0)) /* HSUSB0_DATA5*/\
+ MUX_VAL(CP(HSUSB0_DATA6),	(IEN  | PTD | DIS | M0)) /* HSUSB0_DATA6*/\
+ MUX_VAL(CP(HSUSB0_DATA7),	(IEN  | PTD | DIS | M0)) /* HSUSB0_DATA7*/\
+ MUX_VAL(CP(I2C1_SCL),		(IEN  | PTU | EN  | M0)) /* I2C1_SCL*/\
+ MUX_VAL(CP(I2C1_SDA),		(IEN  | PTU | EN  | M0)) /* I2C1_SDA*/\
+ MUX_VAL(CP(I2C2_SCL),		(IEN  | PTU | EN  | M0)) /* GPIO_168*/\
+ MUX_VAL(CP(I2C2_SDA),		(IEN  | PTU | EN  | M0)) /* GPIO_183*/\
+ MUX_VAL(CP(I2C3_SCL),		(IEN  | PTU | EN  | M0)) /* I2C3_SCL*/\
+ MUX_VAL(CP(I2C3_SDA),		(IEN  | PTU | EN  | M0)) /* I2C3_SDA*/\
+ MUX_VAL(CP(I2C4_SCL),		(IEN  | PTU | EN  | M0)) /* I2C4_SCL*/\
+ MUX_VAL(CP(I2C4_SDA),		(IEN  | PTU | EN  | M0)) /* I2C4_SDA*/\
+ MUX_VAL(CP(HDQ_SIO),		(IDIS | PTU | EN  | M4)) /* GPIO_170*/\
+ /* SPI1 ADC121S101 */ \
+ MUX_VAL(CP(McSPI1_CLK),	(IEN  | PTD | DIS | M0)) /* McSPI1_CLK  */\
+ MUX_VAL(CP(McSPI1_SIMO),	(IEN  | PTD | DIS | M0)) /* McSPI1_SIMO */\
+ MUX_VAL(CP(McSPI1_SOMI),	(IEN  | PTD | DIS | M0)) /* McSPI1_SOMI */\
+ MUX_VAL(CP(McSPI1_CS3),	(IDIS | PTD | DIS | M0)) /* McSPI1_CS3  */\
+ \
+ MUX_VAL(CP(McSPI1_CS0),	(IDIS | PTD | DIS | M0)) /* McSPI1_CS0  */\
+ MUX_VAL(CP(McSPI1_CS1),	(IEN  | PTD | DIS | M4)) /* GPIO_175   */\
+ MUX_VAL(CP(McSPI1_CS2),	(IEN  | PTD | DIS | M4)) /* GPIO_176   */\
+ /* SPI2 (25GHz RF PORT) */ \
+ MUX_VAL(CP(McSPI2_CLK),	(IEN  | PTD | DIS | M0)) /* McSPI2_CLK  */\
+ MUX_VAL(CP(McSPI2_SIMO),	(IEN  | PTD | DIS | M0)) /* McSPI2_SIMO */\
+ MUX_VAL(CP(McSPI2_SOMI),	(IEN  | PTD | DIS | M0)) /* McSPI2_SOMI */\
+ MUX_VAL(CP(McSPI2_CS0),	(IDIS | PTD | DIS | M0)) /* McSPI2_CS0  */\
+ \
+ MUX_VAL(CP(McSPI2_CS1),	(IEN  | PTD | DIS | M4)) /* GPIO_182    */\
+ /* Control and debug */\
+ MUX_VAL(CP(SYS_32K),		(IEN  | PTD | DIS | M0)) /* SYS_32K*/\
+ MUX_VAL(CP(SYS_CLKREQ),	(IEN  | PTD | DIS | M0)) /* SYS_CLKREQ*/\
+ MUX_VAL(CP(SYS_nIRQ),		(IEN  | PTU | EN  | M0)) /* SYS_nIRQ*/\
+ MUX_VAL(CP(SYS_BOOT0),		(IEN  | PTD | DIS | M4)) /* GPIO_2*/\
+ MUX_VAL(CP(SYS_BOOT1),		(IEN  | PTD | DIS | M4)) /* GPIO_3*/\
+ MUX_VAL(CP(SYS_BOOT2),		(IEN  | PTD | DIS | M4)) /* GPIO_4 - MMC1_WP*/\
+ MUX_VAL(CP(SYS_BOOT3),		(IEN  | PTD | DIS | M4)) /* GPIO_5*/\
+ MUX_VAL(CP(SYS_BOOT4),		(IEN  | PTD | DIS | M4)) /* GPIO_6*/\
+ MUX_VAL(CP(SYS_BOOT5),		(IEN  | PTD | DIS | M4)) /* GPIO_7*/\
+ MUX_VAL(CP(SYS_BOOT6),		(IDIS | PTD | DIS | M4)) /* GPIO_8*/ \
+ /* VIO_1V8 */\
+ MUX_VAL(CP(SYS_OFF_MODE),	(IEN  | PTD | DIS | M0)) /* SYS_OFF_MODE*/\
+ MUX_VAL(CP(SYS_CLKOUT1),	(IEN  | PTD | DIS | M0)) /* SYS_CLKOUT1*/\
+ MUX_VAL(CP(SYS_CLKOUT2),	(IEN  | PTU | EN  | M4)) /* GPIO_186*/\
+ /* Generic IO (outputs) */\
+ MUX_VAL(CP(ETK_D10_ES2),	(IDIS | PTU | DIS | M4)) /* GPIO_24  - USB1HS_nRST */\
+ MUX_VAL(CP(ETK_D12_ES2),	(IDIS | PTU | DIS | M4)) /* GPIO_26  - LED1        */\
+ MUX_VAL(CP(ETK_D13_ES2),	(IDIS | PTU | DIS | M4)) /* GPIO_27  - LED0        */\
+ MUX_VAL(CP(CAM_D6),		(IDIS | PTU | DIS | M4)) /* GPIO_105 - RF_CTRL     */\
+ MUX_VAL(CP(CAM_D7),		(IDIS | PTU | DIS | M4)) /* GPIO_106 - RF_STANDBY  */\
+ MUX_VAL(CP(CAM_D8),		(IDIS | PTU | DIS | M4)) /* GPIO_107 - RF_INT      */\
+ MUX_VAL(CP(CAM_D9),		(IDIS | PTU | DIS | M4)) /* GPIO_108 - RF_SYNCB    */\
+ /* Generic IO (inputs) */\
+ MUX_VAL(CP(ETK_D11_ES2),	(IEN  | PTD | DIS | M4)) /* GPIO_25   */\
+ MUX_VAL(CP(ETK_D14_ES2),	(IEN  | PTD | DIS | M4)) /* GPIO_28   */\
+ MUX_VAL(CP(ETK_D15_ES2),	(IEN  | PTD | DIS | M4)) /* GPIO_29   */\
+ MUX_VAL(CP(CAM_D0),		(IEN  | PTD | DIS | M4)) /* GPIO_99   */\
+ MUX_VAL(CP(CAM_D1),		(IEN  | PTD | DIS | M4)) /* GPIO_100  */\
+ MUX_VAL(CP(CSI2_DX0),		(IEN  | PTD | DIS | M4)) /* GPIO_112  */\
+ MUX_VAL(CP(CSI2_DY0),		(IEN  | PTD | DIS | M4)) /* GPIO_113  */\
+ MUX_VAL(CP(CSI2_DX1),		(IEN  | PTD | DIS | M4)) /* GPIO_114  */\
+ MUX_VAL(CP(CSI2_DY1),		(IEN  | PTD | DIS | M4)) /* GPIO_115  */\
+ \
+ \
+ /* LCD_INI */\
+ MUX_VAL(CP(McBSP4_DR),		(IDIS | PTD | DIS | M4)) /* GPIO_153  */\
+ /* LCD_ENVDD */\
+ MUX_VAL(CP(McBSP4_DX),		(IDIS | PTD | DIS | M4)) /* GPIO_154 */\
+ /* LCD_QVGA/nVGA */\
+ MUX_VAL(CP(McBSP4_FSX),	(IDIS | PTD | DIS | M4)) /* GPIO_155 */\
+ /* LCD_RESB */\
+ MUX_VAL(CP(McBSP1_CLKR),	(IDIS | PTD | DIS | M4)) /* GPIO_156 */\
+ MUX_VAL(CP(McBSP1_FSR),	(IDIS | PTU | EN  | M4)) /* GPIO_157 */\
+ MUX_VAL(CP(McBSP1_DX),		(IDIS | PTD | DIS | M4)) /* GPIO_158 */\
+ MUX_VAL(CP(McBSP1_DR),		(IDIS | PTD | DIS | M4)) /* GPIO_159 */\
+ MUX_VAL(CP(McBSP_CLKS),	(IEN  | PTU | DIS | M0)) /* McBSP_CLKS */\
+ MUX_VAL(CP(McBSP1_FSX),	(IDIS | PTD | DIS | M4)) /* GPIO_161 */\
+ MUX_VAL(CP(McBSP1_CLKX),	(IDIS | PTD | DIS | M4)) /* GPIO_162 */\
+ \
+ /* CAMERA */\
+ MUX_VAL(CP(CAM_XCLKA),		(IDIS | PTD | DIS | M0)) /* CAM_XCLKA */\
+ MUX_VAL(CP(CAM_PCLK),		(IEN  | PTU | EN  | M0)) /* CAM_PCLK  */\
+ MUX_VAL(CP(CAM_FLD),		(IDIS | PTD | DIS | M4)) /* GPIO_98   */\
+ MUX_VAL(CP(CAM_D2),		(IEN  | PTD | DIS | M0)) /* CAM_D2    */\
+ MUX_VAL(CP(CAM_D3),		(IEN  | PTD | DIS | M0)) /* CAM_D3    */\
+ MUX_VAL(CP(CAM_D4),		(IEN  | PTD | DIS | M0)) /* CAM_D4    */\
+ MUX_VAL(CP(CAM_D5),		(IEN  | PTD | DIS | M0)) /* CAM_D5    */\
+ MUX_VAL(CP(CAM_D10),		(IEN  | PTD | DIS | M0)) /* CAM_D10   */\
+ MUX_VAL(CP(CAM_D11),		(IEN  | PTD | DIS | M0)) /* CAM_D11   */\
+ MUX_VAL(CP(CAM_XCLKB),		(IDIS | PTD | DIS | M0)) /* CAM_XCLKB */\
+ MUX_VAL(CP(CAM_WEN),		(IEN  | PTD | DIS | M4)) /* GPIO_167  */\
+ MUX_VAL(CP(CAM_STROBE),	(IDIS | PTD | DIS | M0)) /* CAM_STROBE*/\
+ \
+ MUX_VAL(CP(d2d_mcad1),		(IEN  | PTD | EN  | M0)) /*d2d_mcad1*/\
+ MUX_VAL(CP(d2d_mcad2),		(IEN  | PTD | EN  | M0)) /*d2d_mcad2*/\
+ MUX_VAL(CP(d2d_mcad3),		(IEN  | PTD | EN  | M0)) /*d2d_mcad3*/\
+ MUX_VAL(CP(d2d_mcad4),		(IEN  | PTD | EN  | M0)) /*d2d_mcad4*/\
+ MUX_VAL(CP(d2d_mcad5),		(IEN  | PTD | EN  | M0)) /*d2d_mcad5*/\
+ MUX_VAL(CP(d2d_mcad6),		(IEN  | PTD | EN  | M0)) /*d2d_mcad6*/\
+ MUX_VAL(CP(d2d_mcad7),		(IEN  | PTD | EN  | M0)) /*d2d_mcad7*/\
+ MUX_VAL(CP(d2d_mcad8),		(IEN  | PTD | EN  | M0)) /*d2d_mcad8*/\
+ MUX_VAL(CP(d2d_mcad9),		(IEN  | PTD | EN  | M0)) /*d2d_mcad9*/\
+ MUX_VAL(CP(d2d_mcad10),	(IEN  | PTD | EN  | M0)) /*d2d_mcad10*/\
+ MUX_VAL(CP(d2d_mcad11),	(IEN  | PTD | EN  | M0)) /*d2d_mcad11*/\
+ MUX_VAL(CP(d2d_mcad12),	(IEN  | PTD | EN  | M0)) /*d2d_mcad12*/\
+ MUX_VAL(CP(d2d_mcad13),	(IEN  | PTD | EN  | M0)) /*d2d_mcad13*/\
+ MUX_VAL(CP(d2d_mcad14),	(IEN  | PTD | EN  | M0)) /*d2d_mcad14*/\
+ MUX_VAL(CP(d2d_mcad15),	(IEN  | PTD | EN  | M0)) /*d2d_mcad15*/\
+ MUX_VAL(CP(d2d_mcad16),	(IEN  | PTD | EN  | M0)) /*d2d_mcad16*/\
+ MUX_VAL(CP(d2d_mcad17),	(IEN  | PTD | EN  | M0)) /*d2d_mcad17*/\
+ MUX_VAL(CP(d2d_mcad18),	(IEN  | PTD | EN  | M0)) /*d2d_mcad18*/\
+ MUX_VAL(CP(d2d_mcad19),	(IEN  | PTD | EN  | M0)) /*d2d_mcad19*/\
+ MUX_VAL(CP(d2d_mcad20),	(IEN  | PTD | EN  | M0)) /*d2d_mcad20*/\
+ MUX_VAL(CP(d2d_mcad21),	(IEN  | PTD | EN  | M0)) /*d2d_mcad21*/\
+ MUX_VAL(CP(d2d_mcad22),	(IEN  | PTD | EN  | M0)) /*d2d_mcad22*/\
+ MUX_VAL(CP(d2d_mcad23),	(IEN  | PTD | EN  | M0)) /*d2d_mcad23*/\
+ MUX_VAL(CP(d2d_mcad24),	(IEN  | PTD | EN  | M0)) /*d2d_mcad24*/\
+ MUX_VAL(CP(d2d_mcad25),	(IEN  | PTD | EN  | M0)) /*d2d_mcad25*/\
+ MUX_VAL(CP(d2d_mcad26),	(IEN  | PTD | EN  | M0)) /*d2d_mcad26*/\
+ MUX_VAL(CP(d2d_mcad27),	(IEN  | PTD | EN  | M0)) /*d2d_mcad27*/\
+ MUX_VAL(CP(d2d_mcad28),	(IEN  | PTD | EN  | M0)) /*d2d_mcad28*/\
+ MUX_VAL(CP(d2d_mcad29),	(IEN  | PTD | EN  | M0)) /*d2d_mcad29*/\
+ MUX_VAL(CP(d2d_mcad30),	(IEN  | PTD | EN  | M0)) /*d2d_mcad30*/\
+ MUX_VAL(CP(d2d_mcad31),	(IEN  | PTD | EN  | M0)) /*d2d_mcad31*/\
+ MUX_VAL(CP(d2d_mcad32),	(IEN  | PTD | EN  | M0)) /*d2d_mcad32*/\
+ MUX_VAL(CP(d2d_mcad33),	(IEN  | PTD | EN  | M0)) /*d2d_mcad33*/\
+ MUX_VAL(CP(d2d_mcad34),	(IEN  | PTD | EN  | M0)) /*d2d_mcad34*/\
+ MUX_VAL(CP(d2d_mcad35),	(IEN  | PTD | EN  | M0)) /*d2d_mcad35*/\
+ MUX_VAL(CP(d2d_mcad36),	(IEN  | PTD | EN  | M0)) /*d2d_mcad36*/\
+ MUX_VAL(CP(d2d_clk26mi),	(IEN  | PTD | DIS | M0)) /*d2d_clk26mi*/\
+ MUX_VAL(CP(d2d_nrespwron),	(IEN  | PTD | EN  | M0)) /*d2d_nrespwron*/\
+ MUX_VAL(CP(d2d_nreswarm),	(IEN  | PTU | EN  | M0)) /*d2d_nreswarm */\
+ MUX_VAL(CP(d2d_arm9nirq),	(IEN  | PTD | DIS | M0)) /*d2d_arm9nirq */\
+ MUX_VAL(CP(d2d_uma2p6fiq),	(IEN  | PTD | DIS | M0)) /*d2d_uma2p6fiq*/\
+ MUX_VAL(CP(d2d_spint),		(IEN  | PTD | EN  | M0)) /*d2d_spint*/\
+ MUX_VAL(CP(d2d_frint),		(IEN  | PTD | EN  | M0)) /*d2d_frint*/\
+ MUX_VAL(CP(d2d_dmareq0),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq0*/\
+ MUX_VAL(CP(d2d_dmareq1),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq1*/\
+ MUX_VAL(CP(d2d_dmareq2),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq2*/\
+ MUX_VAL(CP(d2d_dmareq3),	(IEN  | PTD | DIS | M0)) /*d2d_dmareq3*/\
+ MUX_VAL(CP(d2d_n3gtrst),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtrst*/\
+ MUX_VAL(CP(d2d_n3gtdi),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtdi*/\
+ MUX_VAL(CP(d2d_n3gtdo),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtdo*/\
+ MUX_VAL(CP(d2d_n3gtms),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtms*/\
+ MUX_VAL(CP(d2d_n3gtck),	(IEN  | PTD | DIS | M0)) /*d2d_n3gtck*/\
+ MUX_VAL(CP(d2d_n3grtck),	(IEN  | PTD | DIS | M0)) /*d2d_n3grtck*/\
+ MUX_VAL(CP(d2d_mstdby),	(IEN  | PTU | EN  | M0)) /*d2d_mstdby*/\
+ MUX_VAL(CP(d2d_swakeup),	(IEN  | PTD | EN  | M0)) /*d2d_swakeup*/\
+ MUX_VAL(CP(d2d_idlereq),	(IEN  | PTD | DIS | M0)) /*d2d_idlereq*/\
+ MUX_VAL(CP(d2d_idleack),	(IEN  | PTU | EN  | M0)) /*d2d_idleack*/\
+ MUX_VAL(CP(d2d_mwrite),	(IEN  | PTD | DIS | M0)) /*d2d_mwrite*/\
+ MUX_VAL(CP(d2d_swrite),	(IEN  | PTD | DIS | M0)) /*d2d_swrite*/\
+ MUX_VAL(CP(d2d_mread),		(IEN  | PTD | DIS | M0)) /*d2d_mread*/\
+ MUX_VAL(CP(d2d_sread),		(IEN  | PTD | DIS | M0)) /*d2d_sread*/\
+ MUX_VAL(CP(d2d_mbusflag),	(IEN  | PTD | DIS | M0)) /*d2d_mbusflag*/\
+ MUX_VAL(CP(d2d_sbusflag),	(IEN  | PTD | DIS | M0)) /*d2d_sbusflag*/\
+ MUX_VAL(CP(sdrc_cke0),		(IDIS | PTU | EN  | M0)) /*sdrc_cke0*/\
+ MUX_VAL(CP(sdrc_cke1),		(IDIS | PTD | DIS | M7)) /*sdrc_cke1*/
+
+
+
 /**********************************************************
  * Routine: set_muxconf_regs
  * Description: Setting up the configuration Mux registers
@@ -1130,7 +1843,8 @@ void per_clocks_enable(void)
  *********************************************************/
 void set_muxconf_regs(void)
 {
-	MUX_DEFAULT();
+	MUX_IGEP0020();
+	//MUX_DEFAULT();
 }
 
 /**********************************************************
@@ -1139,16 +1853,42 @@ void set_muxconf_regs(void)
  *********************************************************/
 int nand_init(void)
 {
+	u32 mem_type;
+
+	mem_type = get_mem_type();
+
+	if(mem_type == GPMC_ONENAND) {
 #ifdef DEBUG
-	onenand_check_maf(ONENAND_MANUF_ID());
-	onenand_print_device_info(ONENAND_DEVICE_ID(), ONENAND_VERSION_ID());
+		onenand_check_maf(ONENAND_MANUF_ID());
+		onenand_print_device_info(ONENAND_DEVICE_ID(), ONENAND_VERSION_ID());
 #endif
+	}
+	else if(mem_type == GPMC_NAND) {
+		if (!nand_mfr) {
+			printf("Error: Unsupported NAND Chip!\n");
+			hang();
+		}
+	}
+	else {
+		printf("IGEP: Flash: unsupported sysboot sequence found\n");
+		hang();
+	}
+
+
 	return 0;
 }
 
 /* optionally do something */
 void board_hang(void)
 {
+	omap_request_gpio(GPIO_LED_USER0);
+	omap_set_gpio_direction(GPIO_LED_USER0, 0);
+	while(1){
+		omap_set_gpio_dataout(GPIO_LED_USER0, 1);
+		udelay(500000);
+		omap_set_gpio_dataout(GPIO_LED_USER0, 0);
+		udelay(500000);
+	}
 }
 
 /******************************************************************************
diff --git a/drivers/Makefile b/drivers/Makefile
index c581817..75d86c8 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -60,6 +60,10 @@ ifeq ($(BOARD), omap1710h3)
 OBJS    += k9f5616.o
 endif
 
+ifeq ($(BOARD), igep0020)
+OBJS   += k9f1g08r0a.o
+endif
+
 
 ## Disabled for now:
 ##	  cs8900.o ct69000.o dataflash.o dc2114x.o ds1722.o \
diff --git a/drivers/k9f1g08r0a.c b/drivers/k9f1g08r0a.c
index 2d635fe..a6ef12c 100644
--- a/drivers/k9f1g08r0a.c
+++ b/drivers/k9f1g08r0a.c
@@ -41,8 +41,35 @@
  * of part/manufacturer
  */
 #define MT29F1G_MFR		0x2c  /* Micron */
-#define MT29F1G_ID		0xa1  /* x8, 1GiB */
-#define MT29F2G_ID      0xba  /* x16, 2GiB */
+#define MT29F1G_ID		0xa1  /* x8, 1Gib */
+#define MT29F2G_ID      0xba  /* x16, 2Gib */
+#define MT29F4G_ID      0xbc  /* x16, 4Gib */
+
+#define NAND_MFR_MICRON_INDEX 0
+#define NAND_MFR_SAMSUNG_INDEX 1
+
+struct nand_mfr_info {
+	char name[20];
+	int id;
+};
+struct nand_chip_info {
+	char name[20];
+	int id;
+	struct nand_mfr_info * mfr;
+};
+
+struct nand_mfr_info nand_mfr_ids[] = {
+	{"Micron", 0x2c},
+	{"Samsung", 0xec},
+};
+
+struct nand_chip_info nand_chip_ids[] = {
+	{"MT29F1G", 0xa1, &nand_mfr_ids[NAND_MFR_MICRON_INDEX]},
+	{"MT29F2G", 0xba, &nand_mfr_ids[NAND_MFR_MICRON_INDEX]},
+	{"MT29F4G", 0xbc, &nand_mfr_ids[NAND_MFR_MICRON_INDEX]},
+	{"K9F1G08R0A", 0xa1, &nand_mfr_ids[NAND_MFR_SAMSUNG_INDEX]},
+};
+#define NAND_NUM_CHIP_IDX 4
 
 #define ADDR_COLUMN		1          
 #define ADDR_PAGE		2             
@@ -158,18 +185,20 @@ static int NanD_Address(unsigned int numbytes, unsigned long ofs)
  */
 int nand_chip()
 {
-	int mfr, id;
+	return read_nand_manufacturer_id(0,0);
+}
+int read_nand_manufacturer_id(u32 *mfr_id, u32 *did)
+{
+	int mfr, cid, idx;
 
  	NAND_ENABLE_CE();
 
  	if (NanD_Command(NAND_CMD_RESET)) {
- 		printf("Err: RESET\n");
  		NAND_DISABLE_CE();   
 		return 1;
 	}
  
  	if (NanD_Command(NAND_CMD_READID)) {
- 		printf("Err: READID\n");
  		NAND_DISABLE_CE();
 		return 1;
  	}
@@ -177,14 +206,38 @@ int nand_chip()
  	NanD_Address(ADDR_COLUMN, 0);
 
  	mfr = READ_NAND(NAND_ADDR);
-	id = READ_NAND(NAND_ADDR);
+	cid = READ_NAND(NAND_ADDR);
 
 	NAND_DISABLE_CE();
 
+	for(idx=0; idx < NAND_NUM_CHIP_IDX; idx++) {
+		if((mfr == nand_chip_ids[idx].mfr->id) &&
+				(cid == nand_chip_ids[idx].id)) {
+			//printf("NAND device: Manufacturer ID:"
+					//" 0x%02x, Chip ID: 0x%02x (%s %s)\n", mfr, cid, 
+					//nand_chip_ids[idx].mfr->name, nand_chip_ids[idx].name);
+			break;
+		}
+	}
+
+	if(idx == NAND_NUM_CHIP_IDX){
+			//printf("Unknown NAND device: Manufacturer ID:"
+					//" 0x%02x, Chip ID: 0x%02x\n", mfr, cid); 
+		return -1;
+	}
+
+
+	if(mfr_id)
+		*mfr_id = mfr;
+	if(did)
+		*did = cid;
+
 	if (get_cpu_rev() == CPU_3430_ES2)
-		return (mfr != MT29F1G_MFR || !(id == MT29F1G_ID || id == MT29F2G_ID));
+		return (mfr != MT29F1G_MFR || 
+				!(cid == MT29F1G_ID || cid == MT29F2G_ID|| cid == MT29F4G_ID));
 	else
-	  	return (mfr != K9F1G08R0A_MFR || id != K9F1G08R0A_ID);
+	  	return (mfr != K9F1G08R0A_MFR || cid != K9F1G08R0A_ID);
+
 }
 
 /* read a block data to buf
diff --git a/include/asm/arch-omap3/cpu.h b/include/asm/arch-omap3/cpu.h
index 790993f..1bbb65d 100644
--- a/include/asm/arch-omap3/cpu.h
+++ b/include/asm/arch-omap3/cpu.h
@@ -40,6 +40,9 @@
 
 /* OMAP 34XX/35XX/36xx/37xx Control ID */
 #define OMAP34XX_CONTROL_ID		(OMAP34XX_WAKEUP_L4_IO_BASE + 0xa204)
+#define OMAP3XXX_STATUS_ID		(OMAP34XX_L4_IO_BASE + 0x244c)
+#define OMAP36XX_CPID           (OMAP34XX_WAKEUP_L4_IO_BASE + 0xa208)
+
 
 /* device type */
 #define DEVICE_MASK		(BIT8|BIT9|BIT10)
@@ -52,6 +55,9 @@
  *  the prirotiy between memory or perpheral booting 
  */
 #define SYSBOOT_MASK		(BIT0|BIT1|BIT2|BIT3|BIT4)
+#define SYSBOOT_NAND           (BIT0|BIT1|BIT2|BIT3)
+#define SYSBOOT_ONENAND                (BIT4)
+
 
 /* GPMC CS3/cs4/cs6 not avaliable */
 #define GPMC_BASE		(OMAP34XX_GPMC_BASE)
@@ -64,6 +70,8 @@
 
 #define GPMC_CONFIG_CS0		(OMAP34XX_GPMC_BASE+0x60)
 #define GPMC_CONFIG_WIDTH	(0x30)
+#define GPMC_CONFIG_CS4		(GPMC_CONFIG_CS0+(4*GPMC_CONFIG_WIDTH))
+#define GPMC_CONFIG_CS5		(GPMC_CONFIG_CS0+(5*GPMC_CONFIG_WIDTH))
 
 #define GPMC_CONFIG1		(0x00)
 #define GPMC_CONFIG2		(0x04)
diff --git a/include/asm/arch-omap3/mem.h b/include/asm/arch-omap3/mem.h
index efcbd43..a6a5f1e 100644
--- a/include/asm/arch-omap3/mem.h
+++ b/include/asm/arch-omap3/mem.h
@@ -86,6 +86,7 @@ typedef enum {
 #define SDP_3430_SDRC_RFR_CTRL_100MHz   0x0002da01
 #define SDP_3430_SDRC_RFR_CTRL_133MHz   0x0003de01 /* 7.8us/7.5ns - 50=0x3de */
 #define SDP_3430_SDRC_RFR_CTRL_165MHz   0x0004e201 /* 7.8us/6ns - 50=0x4e2 */
+#define SDP_3630_SDRC_RFR_CTRL_200MHz   0x0005e601 
 
 #define DLL_OFFSET              0
 #define DLL_WRITEDDRCLKX2DIS    1
@@ -239,6 +240,135 @@ typedef enum {
 #define MICRON_V_ACTIMB_165 ((MICRON_TCKE_165 << 12) | (MICRON_XSR_165 << 0)) | \
 				(MICRON_TXP_165 << 8) | (MICRON_TWTR_165 << 16)
 
+
+/* Micron MT29CXGXXMAXX (133MHz optimized) ~ 7.5ns
+ *	TDAL = Twr/Tck + Trp/tck = 15/7.5 + 22.5/7.5 = 2 + 3 = 5
+ *	TDPL =  15/7.5   = 2
+ *	TRRD =  15/7.5   = 2
+ *	TRCD =  22.5/7.5 = 3
+ *	TRP  =  22.5/7.5 = 3
+ *	TRAS =  45/7.5   = 6
+ *	TRC  =  67.5/7.5   = 9
+ *	TRFC =  72/7.5  = 9.6->10
+ *   ACTIMB
+ *	TWTR =  1
+ *	TCKE =  1
+ *	TXSR =  112.5/7.5  = 15
+ *	TXP  =  1
+ */
+#define MT29CXGXXMAXX_TDAL_133   5
+#define MT29CXGXXMAXX_TDPL_133   2
+#define MT29CXGXXMAXX_TRRD_133   2
+#define MT29CXGXXMAXX_TRCD_133   3
+#define MT29CXGXXMAXX_TRP_133    3
+#define MT29CXGXXMAXX_TRAS_133   6
+#define MT29CXGXXMAXX_TRC_133    9
+#define MT29CXGXXMAXX_TRFC_133   10
+#define MT29CXGXXMAXX_V_ACTIMA_133 ((MT29CXGXXMAXX_TRFC_133 << 27) \
+		| (MT29CXGXXMAXX_TRC_133 << 22) | (MT29CXGXXMAXX_TRAS_133 << 18) \
+		| (MT29CXGXXMAXX_TRP_133 << 15) | (MT29CXGXXMAXX_TRCD_133 << 12) \
+		| (MT29CXGXXMAXX_TRRD_133 << 9) |(MT29CXGXXMAXX_TDPL_133 << 6) \
+		| (MT29CXGXXMAXX_TDAL_133))
+
+#define MT29CXGXXMAXX_TWTR_133   1
+#define MT29CXGXXMAXX_TCKE_133   1
+#define MT29CXGXXMAXX_TXSR_133   15
+#define MT29CXGXXMAXX_TXP_133    1
+#define MT29CXGXXMAXX_V_ACTIMB_133 ((MT29CXGXXMAXX_TWTR_133 << 16) \
+		| (MT29CXGXXMAXX_TCKE_133 << 12) | (MT29CXGXXMAXX_TXP_133 << 8) \
+		| (MT29CXGXXMAXX_TXSR_133 << 0))
+
+#define MT29CXGXXMAXX_V_ACTIMA_100 MT29CXGXXMAXX_V_ACTIMA_133
+#define MT29CXGXXMAXX_V_ACTIMB_100 MT29CXGXXMAXX_V_ACTIMB_133
+
+
+/* Micron MT29CXGXXMAXX (165MHz optimized) 6.06ns
+ *   ACTIMA
+ *	TDAL = Twr/Tck + Trp/tck = 15/6 + 15 /6 = 2.5 + 2.5 = 5
+ *	TDPL (Twr) = 15/6	= 2.5 -> 3
+ *	TRRD = 12/6	= 2
+ *	TRCD = 18/6 = 3
+ *	TRP = 18/6	= 3
+ *	TRAS = 42/6	= 7
+ *	TRC = 60/6	= 10
+ *	TRFC = 72/6	= 12
+ *   ACTIMB
+ *	TWTR =  2
+ *	TCKE =  2
+ *	TXSR =  112.5/6  = 18.75 -> 19
+ *	TXP  =  2
+ */
+#define MT29CXGXXMAXX_TDAL_165   5
+#define MT29CXGXXMAXX_TDPL_165   3
+#define MT29CXGXXMAXX_TRRD_165   2
+#define MT29CXGXXMAXX_TRCD_165   3
+#define MT29CXGXXMAXX_TRP_165    3
+#define MT29CXGXXMAXX_TRAS_165   7
+#define MT29CXGXXMAXX_TRC_165   10
+#define MT29CXGXXMAXX_TRFC_165  12
+#define MT29CXGXXMAXX_V_ACTIMA_165 ((MT29CXGXXMAXX_TRFC_165 << 27) \
+		| (MT29CXGXXMAXX_TRC_165 << 22) | (MT29CXGXXMAXX_TRAS_165 << 18) \
+		| (MT29CXGXXMAXX_TRP_165 << 15) | (MT29CXGXXMAXX_TRCD_165 << 12) \
+		| (MT29CXGXXMAXX_TRRD_165 << 9) | (MT29CXGXXMAXX_TDPL_165 << 6) \
+		| (MT29CXGXXMAXX_TDAL_165))
+
+#define MT29CXGXXMAXX_TWTR_165   2
+#define MT29CXGXXMAXX_TCKE_165   2
+#define MT29CXGXXMAXX_TXP_165    2
+#define MT29CXGXXMAXX_XSR_165    19
+#define MT29CXGXXMAXX_V_ACTIMB_165 ((MT29CXGXXMAXX_TCKE_165 << 12) \
+		| (MT29CXGXXMAXX_XSR_165 << 0)) | (MT29CXGXXMAXX_TXP_165 << 8) \
+		| (MT29CXGXXMAXX_TWTR_165 << 16)
+
+/*
+ * Micron : MT29C4G48MAYAPAKQ-5 IT, MT29C4G48MAZAPAKQ-5 IT,
+ *          MT29C4G96MAZAPCJG-5 IT, MT29C8G96MAZAPDJV-5 IT
+ *
+ * 200MHz (optimized) 5 ns
+ * ACTIMA
+ *	TDAL = 15 / 5 + 15 / 5 = 3 + 3 -> 6
+ *	TDPL (TWR) = 15 / 5 = 3 -> 3
+ *	TRRD = 10 / 5 = 2 -> 2
+ *	TRCD = 15 / 5 = 3 -> 3
+ *	TRP = 15 / 5 = 3 -> 3
+ *	TRAS = 40 / 5 = 8 -> 8
+ *	TRC = 55 / 5 = 11 -> 11
+ *	TRFC = 72 / 5 = 14.5 -> 15
+ * ACTIMB
+ *	TWTR = 2
+ *	TCKE = 2
+ *	TXSR = 112.5 / 5 = 22.5 = 23
+ *	TXP = 2
+ */
+#define MT29CXGXXMAXX_TDAL_200	6
+#define MT29CXGXXMAXX_TDPL_200	3
+#define MT29CXGXXMAXX_TRRD_200	2
+#define MT29CXGXXMAXX_TRCD_200	3
+#define MT29CXGXXMAXX_TRP_200	3
+#define MT29CXGXXMAXX_TRAS_200	8
+#define MT29CXGXXMAXX_TRC_200	11
+#define MT29CXGXXMAXX_TRFC_200	15
+#define MT29CXGXXMAXX_V_ACTIMA_200		\
+	((MT29CXGXXMAXX_TRFC_200 << 27) |	\
+	 (MT29CXGXXMAXX_TRC_200 << 22) |	\
+	 (MT29CXGXXMAXX_TRAS_200 << 18) |	\
+	 (MT29CXGXXMAXX_TRP_200 << 15) |	\
+	 (MT29CXGXXMAXX_TRCD_200 << 12) |	\
+	 (MT29CXGXXMAXX_TRRD_200 << 9) |	\
+	 (MT29CXGXXMAXX_TDPL_200 << 6) |	\
+	 (MT29CXGXXMAXX_TDAL_200))
+
+#define MT29CXGXXMAXX_TWTR_200	2
+#define MT29CXGXXMAXX_TCKE_200	2
+#define MT29CXGXXMAXX_TXSR_200	23
+#define MT29CXGXXMAXX_TXP_200	2
+#define MT29CXGXXMAXX_V_ACTIMB_200		\
+	((MT29CXGXXMAXX_TCKE_200 << 12) |	\
+	 (MT29CXGXXMAXX_TXSR_200 << 0)) |	\
+	(MT29CXGXXMAXX_TXP_200 << 8) |		\
+	(MT29CXGXXMAXX_TWTR_200 << 16)
+
+
 /* NUMONYX part of IGEP0020 (165MHz optimized) 6.06ns
  *   ACTIMA
  *      TDAL = Twr/Tck + Trp/tck = 15/6 + 18/6 = 2.5 + 3 = 5.5 -> 6
@@ -274,6 +404,143 @@ typedef enum {
 #define NUMONYX_V_ACTIMB_165 ((NUMONYX_TCKE_165 << 12) | (NUMONYX_XSR_165 << 0)) | \
 				(NUMONYX_TXP_165 << 8) | (NUMONYX_TWTR_165 << 16)
 
+
+
+/* NUMONYX part of IGEP0020 (200MHz optimized) 5 ns
+ *   ACTIMA
+ *      TDAL = Twr/Tck + Trp/tck = 15/5 + 15/5 = 3 + 3 = 6
+ *      TDPL (Twr) = 15/5 = 3
+ *      TRRD = 10/5 = 2
+ *      TRCD = 16.2/5 = 3.24 -> 4
+ *      TRP  = 15/5 = 3
+ *      TRAS = 40/5 = 8
+ *      TRC  = 55/5 = 11
+ *      TRFC = 140/5 = 28
+ *   ACTIMB
+ *	TWTR = 2
+ *	TCKE = 2
+ *	TXSR = 200/5 =  40
+ *	-> TXP  = 2.0 + 0.9 = 2.9 -> 3 ¿?
+ */
+#define NUMONYX_TDAL_200   6
+#define NUMONYX_TDPL_200   3
+#define NUMONYX_TRRD_200   2
+#define NUMONYX_TRCD_200   4
+#define NUMONYX_TRP_200    3
+#define NUMONYX_TRAS_200   8
+#define NUMONYX_TRC_200   11
+#define NUMONYX_TRFC_200  28
+#define NUMONYX_V_ACTIMA_200 ((NUMONYX_TRFC_200 << 27) | (NUMONYX_TRC_200 << 22) | (NUMONYX_TRAS_200 << 18) \
+		| (NUMONYX_TRP_200 << 15) | (NUMONYX_TRCD_200 << 12) |(NUMONYX_TRRD_200 << 9) | \
+		(NUMONYX_TDPL_200 << 6) | (NUMONYX_TDAL_200))
+
+#define NUMONYX_TWTR_200   2
+#define NUMONYX_TCKE_200   2
+#define NUMONYX_TXP_200   3
+#define NUMONYX_XSR_200    40
+#define NUMONYX_V_ACTIMB_200 ((NUMONYX_TCKE_200 << 12) | (NUMONYX_XSR_200 << 0)) | \
+				(NUMONYX_TXP_200 << 8) | (NUMONYX_TWTR_200 << 16)
+
+
+
+/*
+ * Hynix : H9DH4GH4JJAPER-4EM
+ *
+ * 165MHz (optimized) 6.06ns
+ * ACTIMA
+ *	TDAL = 16 / 6.06 + 16 / 6.06 = 2.6 + 2.6 -> 6
+ *	TDPL (TWR) = 15 / 6.06 = 2.5 -> 3
+ *	TRRD = 12 / 6.06 = 1.98 -> 2
+ *	TRCD = 18 / 6.06 = 2.9 -> 3
+ *	TRP = 18 / 6.06 = 2.9 -> 3
+ *	TRAS = 42 / 6.06 = 6.9 -> 7
+ *	TRC = 55 / 6.06 = 9.1 -> 10
+ *	TRFC = 90 / 6.06 = 14.8 -> 15
+ * ACTIMB
+ *	TWTR = 1
+ *	TCKE = 1
+ *	TXSR = 140 / 6.06 = 23.1 = 24
+ *	TXP = 1
+ */
+#define HYNIX_TDAL_165	6
+#define HYNIX_TDPL_165	3
+#define HYNIX_TRRD_165	2
+#define HYNIX_TRCD_165	3
+#define HYNIX_TRP_165	3
+#define HYNIX_TRAS_165	7
+#define HYNIX_TRC_165	10
+#define HYNIX_TRFC_165	15
+#define HYNIX_V_ACTIMA_165		\
+	((HYNIX_TRFC_165 << 27) |	\
+	 (HYNIX_TRC_165 << 22) |	\
+	 (HYNIX_TRAS_165 << 18) |	\
+	 (HYNIX_TRP_165 << 15) |	\
+	 (HYNIX_TRCD_165 << 12) |	\
+	 (HYNIX_TRRD_165 << 9) |	\
+	 (HYNIX_TDPL_165 << 6) |	\
+	 (HYNIX_TDAL_165))
+
+#define HYNIX_TWTR_165	1
+#define HYNIX_TCKE_165	1
+#define HYNIX_TXSR_165	24
+#define HYNIX_TXP_165	1
+#define HYNIX_V_ACTIMB_165		\
+	((HYNIX_TCKE_165 << 12) |	\
+	 (HYNIX_TXSR_165 << 0)) |	\
+	(HYNIX_TXP_165 << 8) |		\
+	(HYNIX_TWTR_165 << 16)
+
+
+/*
+ * Hynix : H9DH4GH4JJAPER-4EM
+ *
+ * 200MHz (optimized) 5 ns
+ * ACTIMA
+ *	TDAL = 16 / 5 + 16 / 5 = 3.2 + 3.2 -> 7
+ *	TDPL (TWR) = 15 / 5 = 3 -> 3
+ *	TRRD = 10 / 5 = 2 -> 2
+ *	TRCD = 15 / 5 = 3 -> 3
+ *	TRP = 15 / 5 = 3 -> 3
+ *	TRAS = 40 / 5 = 8 -> 8
+ *	TRC = 55 / 5 = 11 -> 11
+ *	TRFC = 90 / 5 = 18 -> 18
+ * ACTIMB
+ *	TWTR = 2
+ *	TCKE = 1
+ *	TXSR = 140 / 5 = 28 = 28
+ *	TXP = 1
+ */
+#define HYNIX_TDAL_200	7
+#define HYNIX_TDPL_200	3
+#define HYNIX_TRRD_200	2
+#define HYNIX_TRCD_200	3
+#define HYNIX_TRP_200	3
+#define HYNIX_TRAS_200	8
+#define HYNIX_TRC_200	11
+#define HYNIX_TRFC_200	18
+#define HYNIX_V_ACTIMA_200		\
+	((HYNIX_TRFC_200 << 27) |	\
+	 (HYNIX_TRC_200 << 22) |	\
+	 (HYNIX_TRAS_200 << 18) |	\
+	 (HYNIX_TRP_200 << 15) |	\
+	 (HYNIX_TRCD_200 << 12) |	\
+	 (HYNIX_TRRD_200 << 9) |	\
+	 (HYNIX_TDPL_200 << 6) |	\
+	 (HYNIX_TDAL_200))
+
+#define HYNIX_TWTR_200	2
+#define HYNIX_TCKE_200	1
+#define HYNIX_TXSR_200	28
+#define HYNIX_TXP_200	1
+#define HYNIX_V_ACTIMB_200		\
+	((HYNIX_TCKE_200 << 12) |	\
+	 (HYNIX_TXSR_200 << 0)) |	\
+	(HYNIX_TXP_200 << 8) |		\
+	(HYNIX_TWTR_200 << 16)
+
+
+
+
 /* New and compatability speed defines */
 #if defined(PRCM_CLK_CFG2_200MHZ) || defined(PRCM_CONFIG_II) || defined(PRCM_CONFIG_5B)
 # define L3_100MHZ   /* Use with <= 100MHz SDRAM */
@@ -292,8 +559,10 @@ typedef enum {
 #elif  defined(L3_165MHZ)
 # define MICRON_SDRC_ACTIM_CTRLA_0     MICRON_V_ACTIMA_165
 # define MICRON_SDRC_ACTIM_CTRLB_0     MICRON_V_ACTIMB_165
-# define NUMONYX_SDRC_ACTIM_CTRLA      NUMONYX_V_ACTIMA_165
-# define NUMONYX_SDRC_ACTIM_CTRLB      NUMONYX_V_ACTIMB_165
+# define NUMONYX_SDRC_ACTIM_CTRLA_165      NUMONYX_V_ACTIMA_165
+# define NUMONYX_SDRC_ACTIM_CTRLB_165      NUMONYX_V_ACTIMB_165
+# define NUMONYX_SDRC_ACTIM_CTRLA_200      NUMONYX_V_ACTIMA_200
+# define NUMONYX_SDRC_ACTIM_CTRLB_200      NUMONYX_V_ACTIMB_200
 #endif
 
 
@@ -313,7 +582,8 @@ typedef enum {
 #elif defined(L3_133MHZ)
 # define SDP_SDRC_RFR_CTRL          SDP_3430_SDRC_RFR_CTRL_133MHz
 #elif  defined(L3_165MHZ)
-# define SDP_SDRC_RFR_CTRL          SDP_3430_SDRC_RFR_CTRL_165MHz
+# define SDP_SDRC_RFR_CTRL_165          SDP_3430_SDRC_RFR_CTRL_165MHz
+# define SDP_SDRC_RFR_CTRL_200          SDP_3630_SDRC_RFR_CTRL_200MHz
 #endif
 
 /*
@@ -524,4 +794,55 @@ typedef enum {
 #define POP_ONEN_BASE		ONENAND_MAP
 #define DBG_MPDB_BASE		DEBUG_BASE
 
+
+// Ethernet NetConfig
+// DM3730 L3 = 200 Mhz -> 1/t = 5 ns
+#define NET_GPMC_CONFIG1	0x00001000
+
+// #define NET_GPMC_CONFIG2	0x001e1e01
+// CS chipselect control time
+// CS ON time = 1 cyle
+// CS RD OFF time = 9 cyles
+// CS WR OFF time = 9 cycles
+#define NET_GPMC_CONFIG2	0x00090901
+
+// #define NET_GPMC_CONFIG3	0x00080300
+// nADV control time
+// Adv ON time = 0 cycles
+// Adv OFF RD time = 3 cycles
+// Adv OFF WR time = 8 cycles
+#define NET_GPMC_CONFIG3	0x00080300
+
+// #define NET_GPMC_CONFIG4	0x1c091c09
+// WR & RD Control time
+// OE on time = 1 cycles
+// OE OFF time = 9 cycles
+// WE on time = 1 cyles
+// WE off time = 9 cycles
+#define NET_GPMC_CONFIG4	0x09010901
+
+// #define NET_GPMC_CONFIG5	0x04181f1f
+// RD AccessTime and Cycle Time
+// RDCYCLETIME = 10 cycles
+// WRCYCLETIME = 10 cycles
+// RDACCESSTIME = 8 cycles
+// PAGE Burst Access time = 3 cycles
+#define NET_GPMC_CONFIG5	0x03080A0A
+
+// #define NET_GPMC_CONFIG6	0x00000FCF ??
+// #define NET_GPMC_CONFIG6	0x88000FCF
+#define NET_GPMC_CONFIG6	0x880002C7
+
+#define NET_GPMC_CONFIG7	0x00000f6c
+
+/* OMAP3530 GPMC settings */
+#define NET_LAN9221_GPMC_CONFIG1    0x00001000
+#define NET_LAN9221_GPMC_CONFIG2    0x00060700
+#define NET_LAN9221_GPMC_CONFIG3    0x00020201
+#define NET_LAN9221_GPMC_CONFIG4    0x06000700
+#define NET_LAN9221_GPMC_CONFIG5    0x0006090A
+#define NET_LAN9221_GPMC_CONFIG6    0x87030000
+#define NET_LAN9221_GPMC_CONFIG7    0x00000f6c
+
+
 #endif /* endif _OMAP34XX_MEM_H_ */
diff --git a/include/common.h b/include/common.h
index 5a6f4c9..4a294a5 100644
--- a/include/common.h
+++ b/include/common.h
@@ -81,6 +81,7 @@ void 	udelay (unsigned long usec);
 #define NAND_CMD_READSTART	0x30
 
 int 	nand_chip(void);
+int		read_nand_manufacturer_id(u32 *mfr_id, u32 *did);
 int 	nand_read_block(uchar *buf, ulong block_addr);
 
 int 	onenand_chip(void);
diff --git a/include/configs/igep0020-flash.h b/include/configs/igep0020-flash.h
index f337e0b..87551a8 100644
--- a/include/configs/igep0020-flash.h
+++ b/include/configs/igep0020-flash.h
@@ -70,8 +70,8 @@
 #define PRCM_PCLK_OPP2		1	/* ARM=381MHz - VDD1=1.20v */
 
 /* Memory type */
-//#define CONFIG_SDRAM_M65KX001AM 1     /* 1Gb, DDR x32, 4KB page */
-#define CONFIG_SDRAM_M65KX002AM 1       /* 2 dice of 2Gb, DDR x32, 4KB page */
+//#define CONFIG_SDRAM_M65KX001AM 1	/* 1Gb, DDR x32, 4KB page */
+#define CONFIG_SDRAM_M65KX002AM 1	/* 2 dice of 2Gb, DDR x32, 4KB page */
 
 /* The actual register values are defined in u-boot- mem.h */
 /* SDRAM Bank Allocation method */
@@ -115,18 +115,85 @@
 #define CONFIG_STACKSIZE	(128*1024) /* regular stack */
 
 /*
+ * Board NAND Info.
+ */
+#define CONFIG_NAND                  1
+//#define NAND_BASE_ADR	ONENAND_MAP
+#define NAND_BASE_ADR	NAND_BASE
+#define CFG_NAND_K9F1G08R0A
+#define NAND_16BIT
+
+/* NAND is partitioned:
+ * 0x00000000 - 0x0007FFFF  X-Loader Image
+ * 0x00080000 - 0x001FFFFF  U-Boot Image
+ * 0x00200000 - 0x0027FFFF  U-Boot Env Data (X-loader doesn't care)
+ * 0x00280000 - 0x0057FFFF  Kernel Image
+ * 0x00580000 - 0x20000000  depends on application
+ */
+#define NAND_UBOOT_START	0x0080000 /* Leaving first 4 blocks for x-load */
+#define NAND_UBOOT_END		0x0240000 /* Giving a space of 2 blocks = 256KB */
+#define NAND_BLOCK_SIZE		0x20000 /* 128K +4K bytes */
+
+#define GPMC_CONFIG		(OMAP34XX_GPMC_BASE+0x50)
+#define GPMC_NAND_COMMAND_0	(OMAP34XX_GPMC_BASE+0x7C)
+#define GPMC_NAND_ADDRESS_0	(OMAP34XX_GPMC_BASE+0x80)
+#define GPMC_NAND_DATA_0	(OMAP34XX_GPMC_BASE+0x84)
+
+
+#ifdef NAND_16BIT
+#define WRITE_NAND_COMMAND(d, adr) \
+	do {*(volatile u16 *)GPMC_NAND_COMMAND_0 = d; } while (0)
+#define WRITE_NAND_ADDRESS(d, adr) \
+	do {*(volatile u16 *)GPMC_NAND_ADDRESS_0 = d; } while (0)
+#define WRITE_NAND(d, adr) \
+	do {*(volatile u16 *)GPMC_NAND_DATA_0 = d; } while (0)
+#define READ_NAND(adr) \
+	(*(volatile u16 *)GPMC_NAND_DATA_0)
+#define NAND_WAIT_READY()
+#define NAND_WP_OFF()  \
+	do {*(volatile u32 *)(GPMC_CONFIG) |= 0x00000010; } while (0)
+#define NAND_WP_ON()  \
+	 do {*(volatile u32 *)(GPMC_CONFIG) &= ~0x00000010; } while (0)
+
+#else /* to support 8-bit NAND devices */
+#define WRITE_NAND_COMMAND(d, adr) \
+	do {*(volatile u8 *)GPMC_NAND_COMMAND_0 = d; } while (0)
+#define WRITE_NAND_ADDRESS(d, adr) \
+	 do {*(volatile u8 *)GPMC_NAND_ADDRESS_0 = d; } while (0)
+#define WRITE_NAND(d, adr) \
+	do {*(volatile u8 *)GPMC_NAND_DATA_0 = d; } while (0)
+#define READ_NAND(adr) \
+	(*(volatile u8 *)GPMC_NAND_DATA_0);
+#define NAND_WAIT_READY()
+#define NAND_WP_OFF()  \
+	do {*(volatile u32 *)(GPMC_CONFIG) |= 0x00000010; } while (0)
+#define NAND_WP_ON()  \
+	do {*(volatile u32 *)(GPMC_CONFIG) &= ~0x00000010; } while (0)
+
+#endif
+
+
+#define NAND_CTL_CLRALE(adr)
+#define NAND_CTL_SETALE(adr)
+#define NAND_CTL_CLRCLE(adr)
+#define NAND_CTL_SETCLE(adr)
+#define NAND_DISABLE_CE()
+#define NAND_ENABLE_CE()
+
+
+/*
  * Board oneNAND Info.
  */
-#define CONFIG_ONENAND			1
-#define CONFIG_MTD_ONENAND_2X_PROGRAM	1
+//#define CONFIG_ONENAND                  1
+//#define CONFIG_MTD_ONENAND_2X_PROGRAM   1
 
-#define ONENAND_BASE    ONENAND_MAP
-#define ONENAND_ADDR    ONENAND_BASE
+#define ONENAND_BASE	ONENAND_MAP
+#define ONENAND_ADDR	ONENAND_BASE
 
-#define ONENAND_START_BLOCK     4        /* 0x00080000 */
-#define ONENAND_END_BLOCK       16       /* 0x00200000 */
-#define ONENAND_PAGE_SIZE       2048     /* 2KB */
-#define ONENAND_BLOCK_SIZE      0x20000  /* 128KB */
+#define ONENAND_START_BLOCK 	4	 /* 0x00080000 */
+#define ONENAND_END_BLOCK	16	 /* 0x00200000 */
+#define ONENAND_PAGE_SIZE	2048     /* 2KB */
+#define ONENAND_BLOCK_SIZE	0x20000  /* 128KB */
 
 #endif /* __CONFIG_H */
 
diff --git a/include/configs/igep0020-sdcard.h b/include/configs/igep0020-sdcard.h
index ff48db9..9502411 100644
--- a/include/configs/igep0020-sdcard.h
+++ b/include/configs/igep0020-sdcard.h
@@ -115,10 +115,77 @@
 #define CONFIG_STACKSIZE	(128*1024) /* regular stack */
 
 /*
+ * Board NAND Info.
+ */
+#define CONFIG_NAND                  1
+//#define NAND_BASE_ADR	ONENAND_MAP
+#define NAND_BASE_ADR	NAND_BASE
+#define CFG_NAND_K9F1G08R0A
+#define NAND_16BIT
+
+/* NAND is partitioned:
+ * 0x00000000 - 0x0007FFFF  X-Loader Image
+ * 0x00080000 - 0x001FFFFF  U-Boot Image
+ * 0x00200000 - 0x0027FFFF  U-Boot Env Data (X-loader doesn't care)
+ * 0x00280000 - 0x0057FFFF  Kernel Image
+ * 0x00580000 - 0x20000000  depends on application
+ */
+#define NAND_UBOOT_START	0x0080000 /* Leaving first 4 blocks for x-load */
+#define NAND_UBOOT_END		0x0240000 /* Giving a space of 2 blocks = 256KB */
+#define NAND_BLOCK_SIZE		0x20000 /* 128K +4K bytes */
+
+#define GPMC_CONFIG		(OMAP34XX_GPMC_BASE+0x50)
+#define GPMC_NAND_COMMAND_0	(OMAP34XX_GPMC_BASE+0x7C)
+#define GPMC_NAND_ADDRESS_0	(OMAP34XX_GPMC_BASE+0x80)
+#define GPMC_NAND_DATA_0	(OMAP34XX_GPMC_BASE+0x84)
+
+
+#ifdef NAND_16BIT
+#define WRITE_NAND_COMMAND(d, adr) \
+	do {*(volatile u16 *)GPMC_NAND_COMMAND_0 = d; } while (0)
+#define WRITE_NAND_ADDRESS(d, adr) \
+	do {*(volatile u16 *)GPMC_NAND_ADDRESS_0 = d; } while (0)
+#define WRITE_NAND(d, adr) \
+	do {*(volatile u16 *)GPMC_NAND_DATA_0 = d; } while (0)
+#define READ_NAND(adr) \
+	(*(volatile u16 *)GPMC_NAND_DATA_0)
+#define NAND_WAIT_READY()
+#define NAND_WP_OFF()  \
+	do {*(volatile u32 *)(GPMC_CONFIG) |= 0x00000010; } while (0)
+#define NAND_WP_ON()  \
+	 do {*(volatile u32 *)(GPMC_CONFIG) &= ~0x00000010; } while (0)
+
+#else /* to support 8-bit NAND devices */
+#define WRITE_NAND_COMMAND(d, adr) \
+	do {*(volatile u8 *)GPMC_NAND_COMMAND_0 = d; } while (0)
+#define WRITE_NAND_ADDRESS(d, adr) \
+	 do {*(volatile u8 *)GPMC_NAND_ADDRESS_0 = d; } while (0)
+#define WRITE_NAND(d, adr) \
+	do {*(volatile u8 *)GPMC_NAND_DATA_0 = d; } while (0)
+#define READ_NAND(adr) \
+	(*(volatile u8 *)GPMC_NAND_DATA_0);
+#define NAND_WAIT_READY()
+#define NAND_WP_OFF()  \
+	do {*(volatile u32 *)(GPMC_CONFIG) |= 0x00000010; } while (0)
+#define NAND_WP_ON()  \
+	do {*(volatile u32 *)(GPMC_CONFIG) &= ~0x00000010; } while (0)
+
+#endif
+
+
+#define NAND_CTL_CLRALE(adr)
+#define NAND_CTL_SETALE(adr)
+#define NAND_CTL_CLRCLE(adr)
+#define NAND_CTL_SETCLE(adr)
+#define NAND_DISABLE_CE()
+#define NAND_ENABLE_CE()
+
+
+/*
  * Board oneNAND Info.
  */
-#define CONFIG_ONENAND                  1
-#define CONFIG_MTD_ONENAND_2X_PROGRAM   1
+//#define CONFIG_ONENAND                  1
+//#define CONFIG_MTD_ONENAND_2X_PROGRAM   1
 
 #define ONENAND_BASE	ONENAND_MAP
 #define ONENAND_ADDR	ONENAND_BASE
diff --git a/lib/board.c b/lib/board.c
index 1a6874d..6863fe9 100644
--- a/lib/board.c
+++ b/lib/board.c
@@ -52,9 +52,7 @@ int print_info(void)
 
 static int init_func_i2c (void)
 {
-#ifdef CONFIG_MMC
 	i2c_init (CFG_I2C_SPEED, CFG_I2C_SLAVE);
-#endif
 	return 0;
 }
 
@@ -62,15 +60,13 @@ typedef int (init_fnc_t) (void);
 
 init_fnc_t *init_sequence[] = {
 	cpu_init,		/* basic cpu dependent setup */
-	board_init,		/* basic board dependent setup */
 #ifdef CFG_NS16550_SERIAL
  	serial_init,		/* serial communications setup */
 #endif
+	init_func_i2c,
+	board_init,		/* basic board dependent setup */
 	print_info,
   	nand_init,		/* board specific nand init */
-#ifdef CONFIG_MMC
-	init_func_i2c,
-#endif
   	NULL,
 };
 
